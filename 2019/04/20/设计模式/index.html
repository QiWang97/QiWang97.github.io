<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="设计模式,">










<meta name="description" content="总结设计模式">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="https://qiwang97.github.io/2019/04/20/设计模式/index.html">
<meta property="og:site_name" content="小柒的博客">
<meta property="og:description" content="总结设计模式">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/421a1a3f-6777-3bca-85d7-00fc60c1ae8b-1555738577904.png">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/84673ccf-ef89-3774-b5cf-6d2523cd03e5-1555738577905.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/34a0f8de-16e0-3cd5-9f69-257fcb2be742-1555738577939.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/e28698b9-994e-3fa8-8810-16f30e7cf3e3.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/6b2d13aa-7cc7-3e98-9764-bdcb2c64f795.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/0aabe35b-5b79-3ead-838f-9d4b6fbd774d.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/a604fca8-e0c6-3e4e-b00a-49da21595b4e.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/e1b8b6a3-0150-31ae-8f77-7c3d888b6f80.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/ea094ad9-efc5-337d-a8e8-ce9223511144.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/eebe2103-6ced-35f2-8664-3a2e8a557f81.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/35f0b172-b976-3757-bb51-c65d5c9ce68e.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/6f713d07-1409-3312-99c9-fa6b0909f0b2.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/09cab656-5ff9-380e-9df1-326339ac3509.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/f7aae0dd-b250-3829-bb07-49d87069bfbb.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/53bc0bf4-cafb-3a12-8574-e20a525f2b72.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/5e2feb58-4170-3c07-a370-ed99bdcab223.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/2319a2c3-7ebd-3ee3-b389-1548074ea9c6.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/c3d57775-ddf9-302b-9dfe-c65967518d3c.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/d588525c-fbad-3040-971c-69b2716c67a4.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/f7571a69-3c85-3fe1-b781-e460563a40a8.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/729a82ce-0987-347c-a4f1-bf64dee59ddb.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/98cda4fc-00b1-300d-a25b-63229f0f1cbd.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/5d3c9b85-c281-3c48-999c-d27095c6ec9f.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/853d5c5a-9b7b-3341-a72e-abd3cbc3c81f.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/006156d2-f41f-3019-a194-b872a59ca426.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/96bd38f3-2888-3cc5-b90f-0e7542dc5845.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/f1f2cc36-ab27-32fa-9906-9cdee2c2b625.jpg">
<meta property="og:image" content="https://qiwang97.github.io/2019/04/20/设计模式/c87e402e-a355-3761-9ce3-7978956ba475.jpg">
<meta property="og:updated_time" content="2019-04-22T04:36:28.072Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式">
<meta name="twitter:description" content="总结设计模式">
<meta name="twitter:image" content="https://qiwang97.github.io/2019/04/20/设计模式/421a1a3f-6777-3bca-85d7-00fc60c1ae8b-1555738577904.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Xiao Qi'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://qiwang97.github.io/2019/04/20/设计模式/">





  <title>设计模式 | 小柒的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/QiWang97" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小柒的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-站点">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点
          </a>
        </li>
      
        
        <li class="menu-item menu-item-baidusitemap">
          <a href="/baidusitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            baidusitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://qiwang97.github.io/2019/04/20/设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xiao Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/album.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小柒的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">设计模式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-20T12:25:31+08:00">
                2019-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  18.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  77 分钟
                </span>
              
            </div>
          

          
              <div class="post-description">
                  总结设计模式
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a><a href="https://www.cnblogs.com/geek6/p/3951677.html" target="_blank" rel="noopener">设计模式的六大原则</a></h2><hr>
<h4 id="总原则：开闭原则（Open-Close-Principle）"><a href="#总原则：开闭原则（Open-Close-Principle）" class="headerlink" title="总原则：开闭原则（Open Close Principle）"></a>总原则：开闭原则（Open Close Principle）</h4><p>开闭原则就是说<strong>对扩展开放，对修改关闭</strong>。</p>
<p>在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。</p>
<h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。</p>
<h4 id="里氏替换原则（Liskov-Substitution-Principle）"><a href="#里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle）"></a>里氏替换原则（Liskov Substitution Principle）</h4><p>里氏代换原则中，任何基类可以出现的地方，子类一定可以出现。</p>
<p>里氏代换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它</p>
<p> LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p>
<h4 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h4><p>面向接口编程，依赖于抽象而不依赖于具体。</p>
<p>写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p>
<h4 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h4><p>每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。</p>
<p>使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p>
<h4 id="迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="迪米特法则（最少知道原则）（Demeter Principle）"></a>迪米特法则（最少知道原则）（Demeter Principle）</h4><p> 一个类对自己依赖的类知道的越少越好。</p>
<p>也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p>
<p>最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</p>
<h4 id="合成复用原则（Composite-Reuse-Principle）"><a href="#合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（Composite Reuse Principle）"></a>合成复用原则（Composite Reuse Principle）</h4><p>尽量首先使用合成/聚合的方式，而不是使用继承。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><hr>
<p>###设计模式的分类</p>
<p>总体来说设计模式分为三大类：</p>
<p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<p>其实还有两类：并发型模式和线程池模式。</p>
<h2 id="Java的23中设计模式"><a href="#Java的23中设计模式" class="headerlink" title="Java的23中设计模式"></a>Java的23中设计模式</h2><h3 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h3><h4 id="0、简单工厂模式"><a href="#0、简单工厂模式" class="headerlink" title="0、简单工厂模式"></a><strong>0、简单工厂模式</strong></h4><p>简单工厂模式模式分为三种：</p>
<h4 id="01、普通"><a href="#01、普通" class="headerlink" title="01、普通"></a><strong>01、普通</strong></h4><p>就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图：</p>
<p><img src="/2019/04/20/设计模式/421a1a3f-6777-3bca-85d7-00fc60c1ae8b-1555738577904.png" alt="img"></p>
<p>举例如下：（我们举一个发送邮件和短信的例子）</p>
<p>首先，创建二者的共同接口：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Sender {  </li>
<li>​    <strong>public</strong> <strong>void</strong> Send();  </li>
<li>}  </li>
</ol>
<p>其次，创建实现类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> MailSender <strong>implements</strong> Sender {  </li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> Send() {  </li>
<li>​        System.out.println(“this is mailsender!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> SmsSender <strong>implements</strong> Sender {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> Send() {  </li>
<li>​        System.out.println(“this is sms sender!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>最后，建工厂类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> SendFactory {  </li>
<li></li>
<li>​    <strong>public</strong> Sender produce(String type) {  </li>
<li>​        <strong>if</strong> (“mail”.equals(type)) {  </li>
<li>​            <strong>return</strong> <strong>new</strong> MailSender();  </li>
<li>​        } <strong>else</strong> <strong>if</strong> (“sms”.equals(type)) {  </li>
<li>​            <strong>return</strong> <strong>new</strong> SmsSender();  </li>
<li>​        } <strong>else</strong> {  </li>
<li>​            System.out.println(“请输入正确的类型!”);  </li>
<li>​            <strong>return</strong> <strong>null</strong>;  </li>
<li>​        }  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>我们来测试下：</p>
<ol>
<li><strong>public</strong> <strong>class</strong> FactoryTest {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        SendFactory factory = <strong>new</strong> SendFactory();  </li>
<li>​        Sender sender = factory.produce(“sms”);  </li>
<li>​        sender.Send();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出：this is sms sender!</p>
<h4 id="02、多个方法"><a href="#02、多个方法" class="headerlink" title="02、多个方法"></a><em>02、多个方法</em></h4><p>是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图：</p>
<p><img src="/2019/04/20/设计模式/84673ccf-ef89-3774-b5cf-6d2523cd03e5-1555738577905.jpg" alt="点击查看原始大小图片"></p>
<p>将上面的代码做下修改，改动下SendFactory类就行，如下：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a><strong>public</strong> <strong>class</strong> SendFactory {  </p>
<p>   <strong>public</strong> Sender produceMail(){  </p>
<ol>
<li>​        <strong>return</strong> <strong>new</strong> MailSender();  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    <strong>public</strong> Sender produceSms(){  </li>
<li>​        <strong>return</strong> <strong>new</strong> SmsSender();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>测试类如下：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> FactoryTest {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        SendFactory factory = <strong>new</strong> SendFactory();  </li>
<li>​        Sender sender = factory.produceMail();  </li>
<li>​        sender.Send();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出：this is mailsender!</p>
<h4 id="03、多个静态方法"><a href="#03、多个静态方法" class="headerlink" title="03、多个静态方法"></a><em>03、多个静态方法</em></h4><p>将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> SendFactory {  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>static</strong> Sender produceMail(){  </li>
<li>​        <strong>return</strong> <strong>new</strong> MailSender();  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>static</strong> Sender produceSms(){  </li>
<li>​        <strong>return</strong> <strong>new</strong> SmsSender();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> FactoryTest {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {      </li>
<li>​        Sender sender = SendFactory.produceMail();  </li>
<li>​        sender.Send();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出：this is mailsender!</p>
<p>总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。</p>
<h4 id="1、工厂方法模式（Factory-Method）"><a href="#1、工厂方法模式（Factory-Method）" class="headerlink" title="1、工厂方法模式（Factory Method）"></a>1、工厂方法模式（Factory Method）</h4><p>简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</p>
<p><img src="/2019/04/20/设计模式/34a0f8de-16e0-3cd5-9f69-257fcb2be742-1555738577939.jpg" alt="点击查看原始大小图片"></p>
<p>请看例子：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Sender {  </li>
<li>​    <strong>public</strong> <strong>void</strong> Send();  </li>
<li>}  </li>
</ol>
<p>两个实现类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> MailSender <strong>implements</strong> Sender {  </li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> Send() {  </li>
<li>​        System.out.println(“this is mailsender!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> SmsSender <strong>implements</strong> Sender {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> Send() {  </li>
<li>​        System.out.println(“this is sms sender!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>两个工厂类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> SendMailFactory <strong>implements</strong> Provider {  </li>
<li>​      </li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> Sender produce(){  </li>
<li>​        <strong>return</strong> <strong>new</strong> MailSender();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> SendSmsFactory <strong>implements</strong> Provider{  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> Sender produce() {  </li>
<li>​        <strong>return</strong> <strong>new</strong> SmsSender();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>在提供一个接口：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Provider {  </li>
<li>​    <strong>public</strong> Sender produce();  </li>
<li>}  </li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Test {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        Provider provider = <strong>new</strong> SendMailFactory();  </li>
<li>​        Sender sender = provider.produce();  </li>
<li>​        sender.Send();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！</p>
<h4 id="2、抽象工厂模式"><a href="#2、抽象工厂模式" class="headerlink" title="2、抽象工厂模式"></a>2、抽象工厂模式</h4><p>工厂方法模式和抽象工厂模式不好分清楚，他们的区别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">工厂方法模式：</span><br><span class="line">一个抽象产品类，可以派生出多个具体产品类。   </span><br><span class="line">一个抽象工厂类，可以派生出多个具体工厂类。   </span><br><span class="line">每个具体工厂类只能创建一个具体产品类的实例。</span><br><span class="line"></span><br><span class="line">抽象工厂模式：</span><br><span class="line">多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   </span><br><span class="line">一个抽象工厂类，可以派生出多个具体工厂类。   </span><br><span class="line">每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。   </span><br><span class="line">    </span><br><span class="line">区别：</span><br><span class="line">工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。   </span><br><span class="line">工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。</span><br><span class="line">工厂方法创建 &quot;一种&quot; 产品，他的着重点在于&quot;怎么创建&quot;，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。 </span><br><span class="line"></span><br><span class="line">抽象工厂需要创建一些列产品，着重点在于&quot;创建哪些&quot;产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">对于java来说，你能见到的大部分抽象工厂模式都是这样的：</span><br><span class="line">---它的里面是一堆工厂方法，每个工厂方法返回某种类型的对象。</span><br><span class="line"></span><br><span class="line">比如说工厂可以生产鼠标和键盘。那么抽象工厂的实现类（它的某个具体子类）的对象都可以生产鼠标和键盘，但可能工厂A生产的是罗技的键盘和鼠标，工厂B是微软的。</span><br><span class="line"></span><br><span class="line">这样A和B就是工厂，对应于抽象工厂；</span><br><span class="line">每个工厂生产的鼠标和键盘就是产品，对应于工厂方法；</span><br><span class="line"></span><br><span class="line">用了工厂方法模式，你替换生成键盘的工厂方法，就可以把键盘从罗技换到微软。但是用了抽象工厂模式，你只要换家工厂，就可以同时替换鼠标和键盘一套。如果你要的产品有几十个，当然用抽象工厂模式一次替换全部最方便（这个工厂会替你用相应的工厂方法）</span><br><span class="line"></span><br><span class="line">所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线</span><br></pre></td></tr></table></figure>
<h4 id="3、单例模式（Singleton）"><a href="#3、单例模式（Singleton）" class="headerlink" title="3、单例模式（Singleton）"></a><strong>3、单例模式（Singleton）</strong></h4><p>单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：</p>
<p>1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。</p>
<p>2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</p>
<p>3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</p>
<p>首先我们写一个简单的单例类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Singleton {  </li>
<li></li>
<li>​    /<em> 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 </em>/  </li>
<li>​    <strong>private</strong> <strong>static</strong> Singleton instance = <strong>null</strong>;  </li>
<li></li>
<li>​    /<em> 私有构造方法，防止被实例化 </em>/  </li>
<li>​    <strong>private</strong> Singleton() {  </li>
<li>​    }  </li>
<li></li>
<li>​    /<em> 静态工程方法，创建实例 </em>/  </li>
<li>​    <strong>public</strong> <strong>static</strong> Singleton getInstance() {  </li>
<li>​        <strong>if</strong> (instance == <strong>null</strong>) {  </li>
<li>​            instance = <strong>new</strong> Singleton();  </li>
<li>​        }  </li>
<li>​        <strong>return</strong> instance;  </li>
<li>​    }  </li>
<li></li>
<li>​    /<em> 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 </em>/  </li>
<li>​    <strong>public</strong> Object readResolve() {  </li>
<li>​        <strong>return</strong> instance;  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>static</strong> <strong>synchronized</strong> Singleton getInstance() {  </li>
<li>​        <strong>if</strong> (instance == <strong>null</strong>) {  </li>
<li>​            instance = <strong>new</strong> Singleton();  </li>
<li>​        }  </li>
<li>​        <strong>return</strong> instance;  </li>
<li>​    }  </li>
</ol>
<p>但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>static</strong> Singleton getInstance() {  </li>
<li>​        <strong>if</strong> (instance == <strong>null</strong>) {  </li>
<li>​            <strong>synchronized</strong> (instance) {  </li>
<li>​                <strong>if</strong> (instance == <strong>null</strong>) {  </li>
<li>​                    instance = <strong>new</strong> Singleton();  </li>
<li>​                }  </li>
<li>​            }  </li>
<li>​        }  </li>
<li>​        <strong>return</strong> instance;  </li>
<li>​    }  </li>
</ol>
<p>似乎解决了之前提到的问题，将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的，看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例：</p>
<p>a&gt;A、B线程同时进入了第一个if判断</p>
<p>b&gt;A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();</p>
<p>c&gt;由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。</p>
<p>d&gt;B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。</p>
<p>e&gt;此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。</p>
<p>所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，尤其是在写多线程环境下的程序更有难度，有挑战性。我们对该程序做进一步优化：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>private</strong> <strong>static</strong> <strong>class</strong> SingletonFactory{           </li>
<li>​        <strong>private</strong> <strong>static</strong> Singleton instance = <strong>new</strong> Singleton();           </li>
<li>​    }           </li>
<li>​    <strong>public</strong> <strong>static</strong> Singleton getInstance(){           </li>
<li>​        <strong>return</strong> SingletonFactory.instance;           </li>
<li>​    }   </li>
</ol>
<p>实际情况是，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Singleton {  </li>
<li></li>
<li>​    /<em> 私有构造方法，防止被实例化 </em>/  </li>
<li>​    <strong>private</strong> Singleton() {  </li>
<li>​    }  </li>
<li></li>
<li>​    /<em> 此处使用一个内部类来维护单例 </em>/  </li>
<li>​    <strong>private</strong> <strong>static</strong> <strong>class</strong> SingletonFactory {  </li>
<li>​        <strong>private</strong> <strong>static</strong> Singleton instance = <strong>new</strong> Singleton();  </li>
<li>​    }  </li>
<li></li>
<li>​    /<em> 获取实例 </em>/  </li>
<li>​    <strong>public</strong> <strong>static</strong> Singleton getInstance() {  </li>
<li>​        <strong>return</strong> SingletonFactory.instance;  </li>
<li>​    }  </li>
<li></li>
<li>​    /<em> 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 </em>/  </li>
<li>​    <strong>public</strong> Object readResolve() {  </li>
<li>​        <strong>return</strong> getInstance();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>其实说它完美，也不一定，如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。也有人这样实现：因为我们只需要在创建类的时候进行同步，所以只要将创建和getInstance()分开，单独为创建加synchronized关键字，也是可以的：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> SingletonTest {  </li>
<li></li>
<li>​    <strong>private</strong> <strong>static</strong> SingletonTest instance = <strong>null</strong>;  </li>
<li></li>
<li>​    <strong>private</strong> SingletonTest() {  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>private</strong> <strong>static</strong> <strong>synchronized</strong> <strong>void</strong> syncInit() {  </li>
<li>​        <strong>if</strong> (instance == <strong>null</strong>) {  </li>
<li>​            instance = <strong>new</strong> SingletonTest();  </li>
<li>​        }  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> SingletonTest getInstance() {  </li>
<li>​        <strong>if</strong> (instance == <strong>null</strong>) {  </li>
<li>​            syncInit();  </li>
<li>​        }  </li>
<li>​        <strong>return</strong> instance;  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>考虑性能的话，整个程序只需创建一次实例，所以性能也不会有什么影响。</p>
<p><strong>补充：采用”影子实例”的办法为单例对象的属性同步更新</strong></p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> SingletonTest {  </li>
<li></li>
<li>​    <strong>private</strong> <strong>static</strong> SingletonTest instance = <strong>null</strong>;  </li>
<li>​    <strong>private</strong> Vector properties = <strong>null</strong>;  </li>
<li></li>
<li>​    <strong>public</strong> Vector getProperties() {  </li>
<li>​        <strong>return</strong> properties;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>private</strong> SingletonTest() {  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>private</strong> <strong>static</strong> <strong>synchronized</strong> <strong>void</strong> syncInit() {  </li>
<li>​        <strong>if</strong> (instance == <strong>null</strong>) {  </li>
<li>​            instance = <strong>new</strong> SingletonTest();  </li>
<li>​        }  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> SingletonTest getInstance() {  </li>
<li>​        <strong>if</strong> (instance == <strong>null</strong>) {  </li>
<li>​            syncInit();  </li>
<li>​        }  </li>
<li>​        <strong>return</strong> instance;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> updateProperties() {  </li>
<li>​        SingletonTest shadow = <strong>new</strong> SingletonTest();  </li>
<li>​        properties = shadow.getProperties();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>通过单例模式的学习告诉我们：</p>
<p>1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。</p>
<p>2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。</p>
<p>到这儿，单例模式基本已经讲完了，结尾处，笔者突然想到另一个问题，就是采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？</p>
<p>首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的）</p>
<p>其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。</p>
<p>再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。</p>
<p>最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。从上面这些概括中，基本可以看出二者的区别，但是，从另一方面讲，我们上面最后实现的那个单例模式，内部就是用一个静态类来实现的，所以，二者有很大的关联，只是我们考虑问题的层面不同罢了。两种思想的结合，才能造就出完美的解决方案，就像HashMap采用数组+链表来实现一样，其实生活中很多事情都是这样，单用不同的方法来处理问题，总是有优点也有缺点，最完美的方法是，结合各个方法的优点，才能最好的解决问题！</p>
<h4 id="4、建造者模式（Builder）"><a href="#4、建造者模式（Builder）" class="headerlink" title="4、建造者模式（Builder）"></a><strong>4、建造者模式（Builder）</strong></h4><h4 id="5、原型模式（Prototype）"><a href="#5、原型模式（Prototype）" class="headerlink" title="5、原型模式（Prototype）"></a><strong>5、原型模式（Prototype）</strong></h4><p>原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Prototype <strong>implements</strong> Cloneable {  </li>
<li></li>
<li>​    <strong>public</strong> Object clone() <strong>throws</strong> CloneNotSupportedException {  </li>
<li>​        Prototype proto = (Prototype) <strong>super</strong>.clone();  </li>
<li>​        <strong>return</strong> proto;  </li>
<li><h4 id><a href="#" class="headerlink" title="}"></a>}</h4></li>
<li>}  </li>
</ol>
<p>很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现，我会在另一篇文章中，关于解读Java中本地方法的调用，此处不再深究。在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念：</p>
<p>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。</p>
<p>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。</p>
<p>此处，写一个深浅复制的例子：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Prototype <strong>implements</strong> Cloneable, Serializable {  </li>
<li></li>
<li>​    <strong>private</strong> <strong>static</strong> <strong>final</strong> <strong>long</strong> serialVersionUID = 1L;  </li>
<li>​    <strong>private</strong> String string;  </li>
<li></li>
<li>​    <strong>private</strong> SerializableObject obj;  </li>
<li></li>
<li>​    /<em> 浅复制 </em>/  </li>
<li>​    <strong>public</strong> Object clone() <strong>throws</strong> CloneNotSupportedException {  </li>
<li>​        Prototype proto = (Prototype) <strong>super</strong>.clone();  </li>
<li>​        <strong>return</strong> proto;  </li>
<li>​    }  </li>
<li></li>
<li>​    /<em> 深复制 </em>/  </li>
<li>​    <strong>public</strong> Object deepClone() <strong>throws</strong> IOException, ClassNotFoundException {  </li>
<li></li>
<li>​        /<em> 写入当前对象的二进制流 </em>/  </li>
<li>​        ByteArrayOutputStream bos = <strong>new</strong> ByteArrayOutputStream();  </li>
<li>​        ObjectOutputStream oos = <strong>new</strong> ObjectOutputStream(bos);  </li>
<li>​        oos.writeObject(<strong>this</strong>);  </li>
<li></li>
<li>​        /<em> 读出二进制流产生的新对象 </em>/  </li>
<li>​        ByteArrayInputStream bis = <strong>new</strong> ByteArrayInputStream(bos.toByteArray());  </li>
<li>​        ObjectInputStream ois = <strong>new</strong> ObjectInputStream(bis);  </li>
<li>​        <strong>return</strong> ois.readObject();  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> String getString() {  </li>
<li>​        <strong>return</strong> string;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> setString(String string) {  </li>
<li>​        <strong>this</strong>.string = string;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> SerializableObject getObj() {  </li>
<li>​        <strong>return</strong> obj;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> setObj(SerializableObject obj) {  </li>
<li>​        <strong>this</strong>.obj = obj;  </li>
<li>​    }  </li>
<li></li>
<li>}  </li>
<li></li>
<li><strong>class</strong> SerializableObject <strong>implements</strong> Serializable {  </li>
<li>​    <strong>private</strong> <strong>static</strong> <strong>final</strong> <strong>long</strong> serialVersionUID = 1L;  </li>
<li>}  </li>
</ol>
<p>要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。</p>
<h3 id="结构模式（7种）"><a href="#结构模式（7种）" class="headerlink" title="结构模式（7种）"></a>结构模式（7种）</h3><p>我们接着讨论设计模式，上篇文章我讲完了5种创建型模式，这章开始，我将讲下7种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。其中对象的适配器模式是各种模式的起源，我们看下面的图：</p>
<p><img src="/2019/04/20/设计模式/e28698b9-994e-3fa8-8810-16f30e7cf3e3.jpg" alt="点击查看原始大小图片"></p>
<h4 id="6、适配器模式"><a href="#6、适配器模式" class="headerlink" title="6、适配器模式"></a>6、适配器模式</h4><p> 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。</p>
<h5 id="01、类的适配器模式"><a href="#01、类的适配器模式" class="headerlink" title="01、类的适配器模式"></a>01、类的适配器模式</h5><p><img src="/2019/04/20/设计模式/6b2d13aa-7cc7-3e98-9764-bdcb2c64f795.jpg" alt="img"></p>
<p>核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Source {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> method1() {  </li>
<li>​        System.out.println(“this is original method!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Targetable {  </li>
<li></li>
<li>​    /<em> 与原类中的方法相同 </em>/  </li>
<li>​    <strong>public</strong> <strong>void</strong> method1();  </li>
<li></li>
<li>​    /<em> 新类的方法 </em>/  </li>
<li>​    <strong>public</strong> <strong>void</strong> method2();  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Adapter <strong>extends</strong> Source <strong>implements</strong> Targetable {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> method2() {  </li>
<li>​        System.out.println(“this is the targetable method!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>Adapter类继承Source类，实现Targetable接口，下面是测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> AdapterTest {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        Targetable target = <strong>new</strong> Adapter();  </li>
<li>​        target.method1();  </li>
<li>​        target.method2();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出：</p>
<p>this is original method!<br>this is the targetable method!</p>
<p>这样Targetable接口的实现类就具有了Source类的功能。</p>
<h5 id="02、对象的适配器模式"><a href="#02、对象的适配器模式" class="headerlink" title="02、对象的适配器模式"></a><strong>02、对象的适配器模式</strong></h5><p>基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。看图：</p>
<p><img src="/2019/04/20/设计模式/0aabe35b-5b79-3ead-838f-9d4b6fbd774d.jpg" alt="img"></p>
<p>只需要修改Adapter类的源码即可：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Wrapper <strong>implements</strong> Targetable {  </li>
<li></li>
<li>​    <strong>private</strong> Source source;  </li>
<li>​      </li>
<li>​    <strong>public</strong> Wrapper(Source source){  </li>
<li>​        <strong>super</strong>();  </li>
<li>​        <strong>this</strong>.source = source;  </li>
<li>​    }  </li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> method2() {  </li>
<li>​        System.out.println(“this is the targetable method!”);  </li>
<li>​    }  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> method1() {  </li>
<li>​        source.method1();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> AdapterTest {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        Source source = <strong>new</strong> Source();  </li>
<li>​        Targetable target = <strong>new</strong> Wrapper(source);  </li>
<li>​        target.method1();  </li>
<li>​        target.method2();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出与第一种一样，只是适配的方法不同而已。</p>
<h4 id="03、接口的适配器模式"><a href="#03、接口的适配器模式" class="headerlink" title="03、接口的适配器模式"></a>03、接口的适配器模式</h4><p>第三种适配器模式是<strong>接口的适配器模式</strong>，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。看一下类图：</p>
<p><img src="/2019/04/20/设计模式/a604fca8-e0c6-3e4e-b00a-49da21595b4e.jpg" alt="img"></p>
<p>这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Sourceable {  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>void</strong> method1();  </li>
<li>​    <strong>public</strong> <strong>void</strong> method2();  </li>
<li>}  </li>
</ol>
<p>抽象类Wrapper2：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>abstract</strong> <strong>class</strong> Wrapper2 <strong>implements</strong> Sourceable{  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>void</strong> method1(){}  </li>
<li>​    <strong>public</strong> <strong>void</strong> method2(){}  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> SourceSub1 <strong>extends</strong> Wrapper2 {  </li>
<li>​    <strong>public</strong> <strong>void</strong> method1(){  </li>
<li>​        System.out.println(“the sourceable interface’s first Sub1!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> SourceSub2 <strong>extends</strong> Wrapper2 {  </li>
<li>​    <strong>public</strong> <strong>void</strong> method2(){  </li>
<li>​        System.out.println(“the sourceable interface’s second Sub2!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> WrapperTest {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        Sourceable source1 = <strong>new</strong> SourceSub1();  </li>
<li>​        Sourceable source2 = <strong>new</strong> SourceSub2();  </li>
<li>​          </li>
<li>​        source1.method1();  </li>
<li>​        source1.method2();  </li>
<li>​        source2.method1();  </li>
<li>​        source2.method2();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>测试输出：</p>
<p>the sourceable interface’s first Sub1!<br>the sourceable interface’s second Sub2!</p>
<p>达到了我们的效果！</p>
<p> 讲了这么多，总结一下三种适配器模式的应用场景：</p>
<p>类的适配器模式：当希望将<strong>一个类</strong>转换成满足<strong>另一个新接口</strong>的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</p>
<p>对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</p>
<p>接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</p>
<h4 id="7、装饰模式（Decorator）"><a href="#7、装饰模式（Decorator）" class="headerlink" title="7、装饰模式（Decorator）"></a><strong>7、装饰模式（Decorator）</strong></h4><p>顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，关系图如下：</p>
<p><img src="/2019/04/20/设计模式/e1b8b6a3-0150-31ae-8f77-7c3d888b6f80.jpg" alt="img"></p>
<p>Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能，代码如下：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Sourceable {  </li>
<li>​    <strong>public</strong> <strong>void</strong> method();  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Source <strong>implements</strong> Sourceable {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> method() {  </li>
<li>​        System.out.println(“the original method!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Decorator <strong>implements</strong> Sourceable {  </li>
<li></li>
<li>​    <strong>private</strong> Sourceable source;  </li>
<li>​      </li>
<li>​    <strong>public</strong> Decorator(Sourceable source){  </li>
<li>​        <strong>super</strong>();  </li>
<li>​        <strong>this</strong>.source = source;  </li>
<li>​    }  </li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> method() {  </li>
<li>​        System.out.println(“before decorator!”);  </li>
<li>​        source.method();  </li>
<li>​        System.out.println(“after decorator!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> DecoratorTest {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        Sourceable source = <strong>new</strong> Source();  </li>
<li>​        Sourceable obj = <strong>new</strong> Decorator(source);  </li>
<li>​        obj.method();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出：</p>
<p>before decorator!<br>the original method!<br>after decorator!</p>
<p>装饰器模式的应用场景：</p>
<p>1、需要扩展一个类的功能。</p>
<p>2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）</p>
<p>缺点：产生过多相似的对象，不易排错！</p>
<h4 id="8、代理模式（Proxy）"><a href="#8、代理模式（Proxy）" class="headerlink" title="8、代理模式（Proxy）"></a>8、代理模式（Proxy）</h4><p>其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。先来看看关系图：<img src="/2019/04/20/设计模式/ea094ad9-efc5-337d-a8e8-ce9223511144.jpg" alt="img"></p>
<p>根据上文的阐述，代理模式就比较容易的理解了，我们看下代码：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Sourceable {  </li>
<li>​    <strong>public</strong> <strong>void</strong> method();  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Source <strong>implements</strong> Sourceable {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> method() {  </li>
<li>​        System.out.println(“the original method!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Proxy <strong>implements</strong> Sourceable {  </li>
<li></li>
<li>​    <strong>private</strong> Source source;  </li>
<li>​    <strong>public</strong> Proxy(){  </li>
<li>​        <strong>super</strong>();  </li>
<li>​        <strong>this</strong>.source = <strong>new</strong> Source();  </li>
<li>​    }  </li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> method() {  </li>
<li>​        before();  </li>
<li>​        source.method();  </li>
<li>​        atfer();  </li>
<li>​    }  </li>
<li>​    <strong>private</strong> <strong>void</strong> atfer() {  </li>
<li>​        System.out.println(“after proxy!”);  </li>
<li>​    }  </li>
<li>​    <strong>private</strong> <strong>void</strong> before() {  </li>
<li>​        System.out.println(“before proxy!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> ProxyTest {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        Sourceable source = <strong>new</strong> Proxy();  </li>
<li>​        source.method();  </li>
<li>​    }  </li>
<li></li>
<li>}  </li>
</ol>
<p>输出：</p>
<p>before proxy!<br>the original method!<br>after proxy!</p>
<p>代理模式的应用场景：</p>
<p>如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：</p>
<p>1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。</p>
<p>2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。</p>
<p>使用代理模式，可以将功能划分的更加清晰，有助于后期维护！</p>
<h4 id="9、外观模式（Facade）"><a href="#9、外观模式（Facade）" class="headerlink" title="9、外观模式（Facade）"></a><strong>9、外观模式（Facade）</strong></h4><p>外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口，看下类图：（我们以一个计算机的启动过程为例）</p>
<p><img src="/2019/04/20/设计模式/eebe2103-6ced-35f2-8664-3a2e8a557f81.jpg" alt="img"></p>
<p>我们先看下实现类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> CPU {  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>void</strong> startup(){  </li>
<li>​        System.out.println(“cpu startup!”);  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>void</strong> shutdown(){  </li>
<li>​        System.out.println(“cpu shutdown!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Memory {  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>void</strong> startup(){  </li>
<li>​        System.out.println(“memory startup!”);  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>void</strong> shutdown(){  </li>
<li>​        System.out.println(“memory shutdown!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Disk {  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>void</strong> startup(){  </li>
<li>​        System.out.println(“disk startup!”);  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>void</strong> shutdown(){  </li>
<li>​        System.out.println(“disk shutdown!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Computer {  </li>
<li>​    <strong>private</strong> CPU cpu;  </li>
<li>​    <strong>private</strong> Memory memory;  </li>
<li>​    <strong>private</strong> Disk disk;  </li>
<li>​      </li>
<li>​    <strong>public</strong> Computer(){  </li>
<li>​        cpu = <strong>new</strong> CPU();  </li>
<li>​        memory = <strong>new</strong> Memory();  </li>
<li>​        disk = <strong>new</strong> Disk();  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>void</strong> startup(){  </li>
<li>​        System.out.println(“start the computer!”);  </li>
<li>​        cpu.startup();  </li>
<li>​        memory.startup();  </li>
<li>​        disk.startup();  </li>
<li>​        System.out.println(“start computer finished!”);  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>void</strong> shutdown(){  </li>
<li>​        System.out.println(“begin to close the computer!”);  </li>
<li>​        cpu.shutdown();  </li>
<li>​        memory.shutdown();  </li>
<li>​        disk.shutdown();  </li>
<li>​        System.out.println(“computer closed!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>User类如下：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> User {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        Computer computer = <strong>new</strong> Computer();  </li>
<li>​        computer.startup();  </li>
<li>​        computer.shutdown();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出：</p>
<p>start the computer!<br>cpu startup!<br>memory startup!<br>disk startup!<br>start computer finished!<br>begin to close the computer!<br>cpu shutdown!<br>memory shutdown!<br>disk shutdown!<br>computer closed!</p>
<p>如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！</p>
<h4 id="10、桥接模式（Bridge）"><a href="#10、桥接模式（Bridge）" class="headerlink" title="10、桥接模式（Bridge）"></a>10、桥接模式（Bridge）</h4><p>桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：<strong>将抽象化与实现化解耦，使得二者可以独立变化</strong>，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。我们来看看关系图：</p>
<p><img src="/2019/04/20/设计模式/35f0b172-b976-3757-bb51-c65d5c9ce68e.jpg" alt="img"></p>
<p>实现代码：</p>
<p>先定义接口：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Sourceable {  </li>
<li>​    <strong>public</strong> <strong>void</strong> method();  </li>
<li>}  </li>
</ol>
<p>分别定义两个实现类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> SourceSub1 <strong>implements</strong> Sourceable {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> method() {  </li>
<li>​        System.out.println(“this is the first sub!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> SourceSub2 <strong>implements</strong> Sourceable {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> method() {  </li>
<li>​        System.out.println(“this is the second sub!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>定义一个桥，持有Sourceable的一个实例：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>abstract</strong> <strong>class</strong> Bridge {  </li>
<li>​    <strong>private</strong> Sourceable source;  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> method(){  </li>
<li>​        source.method();  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    <strong>public</strong> Sourceable getSource() {  </li>
<li>​        <strong>return</strong> source;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> setSource(Sourceable source) {  </li>
<li>​        <strong>this</strong>.source = source;  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> MyBridge <strong>extends</strong> Bridge {  </li>
<li>​    <strong>public</strong> <strong>void</strong> method(){  </li>
<li>​        getSource().method();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> BridgeTest {  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​          </li>
<li>​        Bridge bridge = <strong>new</strong> MyBridge();  </li>
<li>​          </li>
<li>​        /<em>调用第一个对象</em>/  </li>
<li>​        Sourceable source1 = <strong>new</strong> SourceSub1();  </li>
<li>​        bridge.setSource(source1);  </li>
<li>​        bridge.method();  </li>
<li>​          </li>
<li>​        /<em>调用第二个对象</em>/  </li>
<li>​        Sourceable source2 = <strong>new</strong> SourceSub2();  </li>
<li>​        bridge.setSource(source2);  </li>
<li>​        bridge.method();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>output：</p>
<p>this is the first sub!<br>this is the second sub!</p>
<p>这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。接下来我再画个图，大家就应该明白了，因为这个图是我们JDBC连接的原理，有数据库学习基础的，一结合就都懂了。</p>
<p><img src="/2019/04/20/设计模式/6f713d07-1409-3312-99c9-fa6b0909f0b2.jpg" alt="img"></p>
<h4 id="11、组合模式（Composite）"><a href="#11、组合模式（Composite）" class="headerlink" title="11、组合模式（Composite）"></a>11、组合模式（Composite）</h4><p>组合模式有时又叫<strong>部分-整体</strong>模式在处理类似树形结构的问题时比较方便，看看关系图：</p>
<p><img src="/2019/04/20/设计模式/09cab656-5ff9-380e-9df1-326339ac3509.jpg" alt="img"></p>
<p>直接来看代码：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> TreeNode {  </li>
<li>​      </li>
<li>​    <strong>private</strong> String name;  </li>
<li>​    <strong>private</strong> TreeNode parent;  </li>
<li>​    <strong>private</strong> Vector<treenode> children = <strong>new</strong> Vector<treenode>();  </treenode></treenode></li>
<li>​      </li>
<li>​    <strong>public</strong> TreeNode(String name){  </li>
<li>​        <strong>this</strong>.name = name;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> String getName() {  </li>
<li>​        <strong>return</strong> name;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> setName(String name) {  </li>
<li>​        <strong>this</strong>.name = name;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> TreeNode getParent() {  </li>
<li>​        <strong>return</strong> parent;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> setParent(TreeNode parent) {  </li>
<li>​        <strong>this</strong>.parent = parent;  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    //添加孩子节点  </li>
<li>​    <strong>public</strong> <strong>void</strong> add(TreeNode node){  </li>
<li>​        children.add(node);  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    //删除孩子节点  </li>
<li>​    <strong>public</strong> <strong>void</strong> remove(TreeNode node){  </li>
<li>​        children.remove(node);  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    //取得孩子节点  </li>
<li>​    <strong>public</strong> Enumeration<treenode> getChildren(){  </treenode></li>
<li>​        <strong>return</strong> children.elements();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Tree {  </li>
<li></li>
<li>​    TreeNode root = <strong>null</strong>;  </li>
<li></li>
<li>​    <strong>public</strong> Tree(String name) {  </li>
<li>​        root = <strong>new</strong> TreeNode(name);  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        Tree tree = <strong>new</strong> Tree(“A”);  </li>
<li>​        TreeNode nodeB = <strong>new</strong> TreeNode(“B”);  </li>
<li>​        TreeNode nodeC = <strong>new</strong> TreeNode(“C”);  </li>
<li>​          </li>
<li>​        nodeB.add(nodeC);  </li>
<li>​        tree.root.add(nodeB);  </li>
<li>​        System.out.println(“build the tree finished!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。</p>
<p><strong>12、享元模式（Flyweight）</strong></p>
<p>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。</p>
<p><img src="/2019/04/20/设计模式/f7aae0dd-b250-3829-bb07-49d87069bfbb.jpg" alt="img"></p>
<p>FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。</p>
<p>看个例子：</p>
<p><img src="/2019/04/20/设计模式/53bc0bf4-cafb-3a12-8574-e20a525f2b72.jpg" alt="img"></p>
<p>看下数据库连接池的代码：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> ConnectionPool {  </li>
<li>​      </li>
<li>​    <strong>private</strong> Vector<connection> pool;  </connection></li>
<li>​      </li>
<li>​    /<em>公有属性</em>/  </li>
<li>​    <strong>private</strong> String url = “jdbc:mysql://localhost:3306/test”;  </li>
<li>​    <strong>private</strong> String username = “root”;  </li>
<li>​    <strong>private</strong> String password = “root”;  </li>
<li>​    <strong>private</strong> String driverClassName = “com.mysql.jdbc.Driver”;  </li>
<li></li>
<li>​    <strong>private</strong> <strong>int</strong> poolSize = 100;  </li>
<li>​    <strong>private</strong> <strong>static</strong> ConnectionPool instance = <strong>null</strong>;  </li>
<li>​    Connection conn = <strong>null</strong>;  </li>
<li></li>
<li>​    /<em>构造方法，做一些初始化工作</em>/  </li>
<li>​    <strong>private</strong> ConnectionPool() {  </li>
<li>​        pool = <strong>new</strong> Vector<connection>(poolSize);  </connection></li>
<li></li>
<li>​        <strong>for</strong> (<strong>int</strong> i = 0; i &lt; poolSize; i++) {  </li>
<li>​            <strong>try</strong> {  </li>
<li>​                Class.forName(driverClassName);  </li>
<li>​                conn = DriverManager.getConnection(url, username, password);  </li>
<li>​                pool.add(conn);  </li>
<li>​            } <strong>catch</strong> (ClassNotFoundException e) {  </li>
<li>​                e.printStackTrace();  </li>
<li>​            } <strong>catch</strong> (SQLException e) {  </li>
<li>​                e.printStackTrace();  </li>
<li>​            }  </li>
<li>​        }  </li>
<li>​    }  </li>
<li></li>
<li>​    /<em> 返回连接到连接池 </em>/  </li>
<li>​    <strong>public</strong> <strong>synchronized</strong> <strong>void</strong> release() {  </li>
<li>​        pool.add(conn);  </li>
<li>​    }  </li>
<li></li>
<li>​    /<em> 返回连接池中的一个数据库连接 </em>/  </li>
<li>​    <strong>public</strong> <strong>synchronized</strong> Connection getConnection() {  </li>
<li>​        <strong>if</strong> (pool.size() &gt; 0) {  </li>
<li>​            Connection conn = pool.get(0);  </li>
<li>​            pool.remove(conn);  </li>
<li>​            <strong>return</strong> conn;  </li>
<li>​        } <strong>else</strong> {  </li>
<li>​            <strong>return</strong> <strong>null</strong>;  </li>
<li>​        }  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！</p>
<h3 id="关系模式（11种）"><a href="#关系模式（11种）" class="headerlink" title="关系模式（11种）"></a><strong>关系模式（11种）</strong></h3><p>先来张图，看看这11中模式的关系：</p>
<p>第一类：通过父类与子类的关系进行实现。</p>
<p>第二类：两个类之间。</p>
<p>第三类：类的状态。</p>
<p>第四类：通过中间类</p>
<p><img src="/2019/04/20/设计模式/5e2feb58-4170-3c07-a370-ed99bdcab223.jpg" alt="img"></p>
<h4 id="父类与子类关系"><a href="#父类与子类关系" class="headerlink" title="父类与子类关系"></a>父类与子类关系</h4><h4 id="13、策略模式（strategy）"><a href="#13、策略模式（strategy）" class="headerlink" title="13、策略模式（strategy）"></a>13、策略模式（strategy）</h4><p>策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数，关系图如下：</p>
<p><img src="/2019/04/20/设计模式/2319a2c3-7ebd-3ee3-b389-1548074ea9c6.jpg" alt="img"></p>
<p>图中ICalculator提供同意的方法，<br>AbstractCalculator是辅助类，提供辅助方法，接下来，依次实现下每个类：</p>
<p>首先统一接口：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> ICalculator {  </li>
<li>​    <strong>public</strong> <strong>int</strong> calculate(String exp);  </li>
<li>}  </li>
</ol>
<p>辅助类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>abstract</strong> <strong>class</strong> AbstractCalculator {  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>int</strong>[] split(String exp,String opt){  </li>
<li>​        String array[] = exp.split(opt);  </li>
<li>​        <strong>int</strong> arrayInt[] = <strong>new</strong> <strong>int</strong>[2];  </li>
<li>​        arrayInt[0] = Integer.parseInt(array[0]);  </li>
<li>​        arrayInt[1] = Integer.parseInt(array[1]);  </li>
<li>​        <strong>return</strong> arrayInt;  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>三个实现类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Plus <strong>extends</strong> AbstractCalculator <strong>implements</strong> ICalculator {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>int</strong> calculate(String exp) {  </li>
<li>​        <strong>int</strong> arrayInt[] = split(exp,”\+”);  </li>
<li>​        <strong>return</strong> arrayInt[0]+arrayInt[1];  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Minus <strong>extends</strong> AbstractCalculator <strong>implements</strong> ICalculator {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>int</strong> calculate(String exp) {  </li>
<li>​        <strong>int</strong> arrayInt[] = split(exp,”-“);  </li>
<li>​        <strong>return</strong> arrayInt[0]-arrayInt[1];  </li>
<li>​    }  </li>
<li></li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Multiply <strong>extends</strong> AbstractCalculator <strong>implements</strong> ICalculator {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>int</strong> calculate(String exp) {  </li>
<li>​        <strong>int</strong> arrayInt[] = split(exp,”\*”);  </li>
<li>​        <strong>return</strong> arrayInt[0]*arrayInt[1];  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>简单的测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> StrategyTest {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        String exp = “2+8”;  </li>
<li>​        ICalculator cal = <strong>new</strong> Plus();  </li>
<li>​        <strong>int</strong> result = cal.calculate(exp);  </li>
<li>​        System.out.println(result);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出：10</p>
<p>策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。</p>
<h4 id="14、模板方法模式（Template-Method）"><a href="#14、模板方法模式（Template-Method）" class="headerlink" title="14、模板方法模式（Template Method）"></a>14、模板方法模式（Template Method）</h4><p>解释一下模板方法模式，就是指：一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用，先看个关系图：</p>
<p><img src="/2019/04/20/设计模式/c3d57775-ddf9-302b-9dfe-c65967518d3c.jpg" alt="img"></p>
<p>就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用，看下面的例子：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>abstract</strong> <strong>class</strong> AbstractCalculator {  </li>
<li>​      </li>
<li>​    /<em>主方法，实现对本类其它方法的调用</em>/  </li>
<li>​    <strong>public</strong> <strong>final</strong> <strong>int</strong> calculate(String exp,String opt){  </li>
<li>​        <strong>int</strong> array[] = split(exp,opt);  </li>
<li>​        <strong>return</strong> calculate(array[0],array[1]);  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    /<em>被子类重写的方法</em>/  </li>
<li>​    <strong>abstract</strong> <strong>public</strong> <strong>int</strong> calculate(<strong>int</strong> num1,<strong>int</strong> num2);  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>int</strong>[] split(String exp,String opt){  </li>
<li>​        String array[] = exp.split(opt);  </li>
<li>​        <strong>int</strong> arrayInt[] = <strong>new</strong> <strong>int</strong>[2];  </li>
<li>​        arrayInt[0] = Integer.parseInt(array[0]);  </li>
<li>​        arrayInt[1] = Integer.parseInt(array[1]);  </li>
<li>​        <strong>return</strong> arrayInt;  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Plus <strong>extends</strong> AbstractCalculator {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>int</strong> calculate(<strong>int</strong> num1,<strong>int</strong> num2) {  </li>
<li>​        <strong>return</strong> num1 + num2;  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> StrategyTest {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        String exp = “8+8”;  </li>
<li>​        AbstractCalculator cal = <strong>new</strong> Plus();  </li>
<li>​        <strong>int</strong> result = cal.calculate(exp, “\+”);  </li>
<li>​        System.out.println(result);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>我跟踪下这个小程序的执行过程：首先将exp和”\+”做参数，调用AbstractCalculator类里的calculate(String,String)方法，在calculate(String,String)里调用同类的split()，之后再调用calculate(int ,int)方法，从这个方法进入到子类中，执行完return num1 + num2后，将值返回到AbstractCalculator类，赋给result，打印出来。正好验证了我们开头的思路。</p>
<h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><h4 id="15、观察者模式（Observer）"><a href="#15、观察者模式（Observer）" class="headerlink" title="15、观察者模式（Observer）"></a>15、观察者模式（Observer）</h4><p>包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。先来看看关系图：</p>
<p><img src="/2019/04/20/设计模式/d588525c-fbad-3040-971c-69b2716c67a4.jpg" alt="img"></p>
<p>我解释下这些类的作用：MySubject类就是我们的主对象，Observer1和Observer2是依赖于MySubject的对象，当MySubject变化时，Observer1和Observer2必然变化。AbstractSubject类中定义着需要监控的对象列表，可以对其进行修改：增加或删除被监控对象，且当MySubject变化时，负责通知在列表内存在的对象。我们看实现代码：</p>
<p>一个Observer接口：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Observer {  </li>
<li>​    <strong>public</strong> <strong>void</strong> update();  </li>
<li>}  </li>
</ol>
<p>两个实现类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Observer1 <strong>implements</strong> Observer {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> update() {  </li>
<li>​        System.out.println(“observer1 has received!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Observer2 <strong>implements</strong> Observer {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> update() {  </li>
<li>​        System.out.println(“observer2 has received!”);  </li>
<li>​    }  </li>
<li></li>
<li>}  </li>
</ol>
<p>Subject接口及实现类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Subject {  </li>
<li>​      </li>
<li>​    /<em>增加观察者</em>/  </li>
<li>​    <strong>public</strong> <strong>void</strong> add(Observer observer);  </li>
<li>​      </li>
<li>​    /<em>删除观察者</em>/  </li>
<li>​    <strong>public</strong> <strong>void</strong> del(Observer observer);  </li>
<li>​      </li>
<li>​    /<em>通知所有的观察者</em>/  </li>
<li>​    <strong>public</strong> <strong>void</strong> notifyObservers();  </li>
<li>​      </li>
<li>​    /<em>自身的操作</em>/  </li>
<li>​    <strong>public</strong> <strong>void</strong> operation();  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>abstract</strong> <strong>class</strong> AbstractSubject <strong>implements</strong> Subject {  </li>
<li></li>
<li>​    <strong>private</strong> Vector<observer> vector = <strong>new</strong> Vector<observer>();  </observer></observer></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> add(Observer observer) {  </li>
<li>​        vector.add(observer);  </li>
<li>​    }  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> del(Observer observer) {  </li>
<li>​        vector.remove(observer);  </li>
<li>​    }  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> notifyObservers() {  </li>
<li>​        Enumeration<observer> enumo = vector.elements();  </observer></li>
<li>​        <strong>while</strong>(enumo.hasMoreElements()){  </li>
<li>​            enumo.nextElement().update();  </li>
<li>​        }  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> MySubject <strong>extends</strong> AbstractSubject {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> operation() {  </li>
<li>​        System.out.println(“update self!”);  </li>
<li>​        notifyObservers();  </li>
<li>​    }  </li>
<li></li>
<li>}  </li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> ObserverTest {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        Subject sub = <strong>new</strong> MySubject();  </li>
<li>​        sub.add(<strong>new</strong> Observer1());  </li>
<li>​        sub.add(<strong>new</strong> Observer2());  </li>
<li>​          </li>
<li>​        sub.operation();  </li>
<li>​    }  </li>
<li></li>
<li>}  </li>
</ol>
<p>输出：</p>
<p>update self!<br>observer1 has received!<br>observer2 has received!</p>
<p> 这些东西，其实不难，只是有些抽象，不太容易整体理解，建议读者：<strong>根据关系图，新建项目，自己写代码（或者参考我的代码）,按照总体思路走一遍，这样才能体会它的思想，理解起来容易！</strong></p>
<h4 id="16、迭代子模式（Iterator）"><a href="#16、迭代子模式（Iterator）" class="headerlink" title="16、迭代子模式（Iterator）"></a><strong>16、迭代子模式（Iterator）</strong></h4><p>顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。我们看下关系图：</p>
<p> <img src="/2019/04/20/设计模式/f7571a69-3c85-3fe1-b781-e460563a40a8.jpg" alt="img"></p>
<p>这个思路和我们常用的一模一样，MyCollection中定义了集合的一些操作，MyIterator中定义了一系列迭代操作，且持有Collection实例，我们来看看实现代码：</p>
<p>两个接口：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Collection {  </li>
<li>​      </li>
<li>​    <strong>public</strong> Iterator iterator();  </li>
<li>​      </li>
<li>​    /<em>取得集合元素</em>/  </li>
<li>​    <strong>public</strong> Object get(<strong>int</strong> i);  </li>
<li>​      </li>
<li>​    /<em>取得集合大小</em>/  </li>
<li>​    <strong>public</strong> <strong>int</strong> size();  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Iterator {  </li>
<li>​    //前移  </li>
<li>​    <strong>public</strong> Object previous();  </li>
<li>​      </li>
<li>​    //后移  </li>
<li>​    <strong>public</strong> Object next();  </li>
<li>​    <strong>public</strong> <strong>boolean</strong> hasNext();  </li>
<li>​      </li>
<li>​    //取得第一个元素  </li>
<li>​    <strong>public</strong> Object first();  </li>
<li>}  </li>
</ol>
<p>两个实现：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> MyCollection <strong>implements</strong> Collection {  </li>
<li></li>
<li>​    <strong>public</strong> String string[] = {“A”,”B”,”C”,”D”,”E”};  </li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> Iterator iterator() {  </li>
<li>​        <strong>return</strong> <strong>new</strong> MyIterator(<strong>this</strong>);  </li>
<li>​    }  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> Object get(<strong>int</strong> i) {  </li>
<li>​        <strong>return</strong> string[i];  </li>
<li>​    }  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>int</strong> size() {  </li>
<li>​        <strong>return</strong> string.length;  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> MyIterator <strong>implements</strong> Iterator {  </li>
<li></li>
<li>​    <strong>private</strong> Collection collection;  </li>
<li>​    <strong>private</strong> <strong>int</strong> pos = -1;  </li>
<li>​      </li>
<li>​    <strong>public</strong> MyIterator(Collection collection){  </li>
<li>​        <strong>this</strong>.collection = collection;  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> Object previous() {  </li>
<li>​        <strong>if</strong>(pos &gt; 0){  </li>
<li>​            pos–;  </li>
<li>​        }  </li>
<li>​        <strong>return</strong> collection.get(pos);  </li>
<li>​    }  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> Object next() {  </li>
<li>​        <strong>if</strong>(pos&lt;collection.size()-1){  </li>
<li>​            pos++;  </li>
<li>​        }  </li>
<li>​        <strong>return</strong> collection.get(pos);  </li>
<li>​    }  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>boolean</strong> hasNext() {  </li>
<li>​        <strong>if</strong>(pos&lt;collection.size()-1){  </li>
<li>​            <strong>return</strong> <strong>true</strong>;  </li>
<li>​        }<strong>else</strong>{  </li>
<li>​            <strong>return</strong> <strong>false</strong>;  </li>
<li>​        }  </li>
<li>​    }  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> Object first() {  </li>
<li>​        pos = 0;  </li>
<li>​        <strong>return</strong> collection.get(pos);  </li>
<li>​    }  </li>
<li></li>
<li>}  </li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Test {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        Collection collection = <strong>new</strong> MyCollection();  </li>
<li>​        Iterator it = collection.iterator();  </li>
<li>​          </li>
<li>​        <strong>while</strong>(it.hasNext()){  </li>
<li>​            System.out.println(it.next());  </li>
<li>​        }  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出：A B C D E</p>
<p>此处我们貌似模拟了一个集合类的过程，感觉是不是很爽？其实JDK中各个类也都是这些基本的东西，加一些设计模式，再加一些优化放到一起的，只要我们把这些东西学会了，掌握好了，我们也可以写出自己的集合类，甚至框架！</p>
<h4 id="17、责任链模式（Chain-of-Responsibility）"><a href="#17、责任链模式（Chain-of-Responsibility）" class="headerlink" title="17、责任链模式（Chain of Responsibility）"></a>17、责任链模式（Chain of Responsibility）</h4><p>接下来我们将要谈谈责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。先看看关系图：</p>
<p> <img src="/2019/04/20/设计模式/729a82ce-0987-347c-a4f1-bf64dee59ddb.jpg" alt="img"></p>
<p>Abstracthandler类提供了get和set方法，方便MyHandle类设置和修改引用对象，MyHandle类是核心，实例化后生成一系列相互持有的对象，构成一条链。</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Handler {  </li>
<li>​    <strong>public</strong> <strong>void</strong> operator();  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>abstract</strong> <strong>class</strong> AbstractHandler {  </li>
<li>​      </li>
<li>​    <strong>private</strong> Handler handler;  </li>
<li></li>
<li>​    <strong>public</strong> Handler getHandler() {  </li>
<li>​        <strong>return</strong> handler;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> setHandler(Handler handler) {  </li>
<li>​        <strong>this</strong>.handler = handler;  </li>
<li>​    }  </li>
<li>​      </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> MyHandler <strong>extends</strong> AbstractHandler <strong>implements</strong> Handler {  </li>
<li></li>
<li>​    <strong>private</strong> String name;  </li>
<li></li>
<li>​    <strong>public</strong> MyHandler(String name) {  </li>
<li>​        <strong>this</strong>.name = name;  </li>
<li>​    }  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> operator() {  </li>
<li>​        System.out.println(name+”deal!”);  </li>
<li>​        <strong>if</strong>(getHandler()!=<strong>null</strong>){  </li>
<li>​            getHandler().operator();  </li>
<li>​        }  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Test {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        MyHandler h1 = <strong>new</strong> MyHandler(“h1”);  </li>
<li>​        MyHandler h2 = <strong>new</strong> MyHandler(“h2”);  </li>
<li>​        MyHandler h3 = <strong>new</strong> MyHandler(“h3”);  </li>
<li></li>
<li>​        h1.setHandler(h2);  </li>
<li>​        h2.setHandler(h3);  </li>
<li></li>
<li>​        h1.operator();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出：</p>
<p>h1deal!<br>h2deal!<br>h3deal!</p>
<p>此处强调一点就是，链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。</p>
<h4 id="18、命令模式（Command）"><a href="#18、命令模式（Command）" class="headerlink" title="18、命令模式（Command）"></a>18、命令模式（Command）</h4><p>命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。我们看看关系图：</p>
<p><img src="/2019/04/20/设计模式/98cda4fc-00b1-300d-a25b-63229f0f1cbd.jpg" alt="img"></p>
<h4 id="Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码："><a href="#Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码：" class="headerlink" title="Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码："></a>Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码：</h4><p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Command {  </li>
<li>​    <strong>public</strong> <strong>void</strong> exe();  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> MyCommand <strong>implements</strong> Command {  </li>
<li></li>
<li>​    <strong>private</strong> Receiver receiver;  </li>
<li>​      </li>
<li>​    <strong>public</strong> MyCommand(Receiver receiver) {  </li>
<li>​        <strong>this</strong>.receiver = receiver;  </li>
<li>​    }  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> exe() {  </li>
<li>​        receiver.action();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Receiver {  </li>
<li>​    <strong>public</strong> <strong>void</strong> action(){  </li>
<li>​        System.out.println(“command received!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Invoker {  </li>
<li>​      </li>
<li>​    <strong>private</strong> Command command;  </li>
<li>​      </li>
<li>​    <strong>public</strong> Invoker(Command command) {  </li>
<li>​        <strong>this</strong>.command = command;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> action(){  </li>
<li>​        command.exe();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Test {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        Receiver receiver = <strong>new</strong> Receiver();  </li>
<li>​        Command cmd = <strong>new</strong> MyCommand(receiver);  </li>
<li>​        Invoker invoker = <strong>new</strong> Invoker(cmd);  </li>
<li>​        invoker.action();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出：command received!</p>
<p>这个很哈理解，命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！</p>
<p>其实每个设计模式都是很重要的一种思想，看上去很熟，其实是因为我们在学到的东西中都有涉及，尽管有时我们并不知道，其实在Java本身的设计之中处处都有体现，像AWT、JDBC、集合类、IO管道或者是Web框架，里面设计模式无处不在。因为我们篇幅有限，很难讲每一个设计模式都讲的很详细，不过我会尽我所能，尽量在有限的空间和篇幅内，把意思写清楚了，更好让大家明白。本章不出意外的话，应该是设计模式最后一讲了，首先还是上一下上篇开头的那个图：</p>
<p><img src="/2019/04/20/设计模式/5d3c9b85-c281-3c48-999c-d27095c6ec9f.jpg" alt="点击查看原始大小图片"></p>
<h4 id="类的状态"><a href="#类的状态" class="headerlink" title="类的状态"></a>类的状态</h4><h4 id="19、备忘录模式（Memento）"><a href="#19、备忘录模式（Memento）" class="headerlink" title="19、备忘录模式（Memento）"></a><strong>19、备忘录模式（Memento）</strong></h4><p>主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。做个图来分析一下：</p>
<p><img src="/2019/04/20/设计模式/853d5c5a-9b7b-3341-a72e-abd3cbc3c81f.jpg" alt="img"></p>
<p>Original类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。Memento类是备忘录类，Storage类是存储备忘录的类，持有Memento类的实例，该模式很好理解。直接看源码：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Original {  </li>
<li>​      </li>
<li>​    <strong>private</strong> String value;  </li>
<li>​      </li>
<li>​    <strong>public</strong> String getValue() {  </li>
<li>​        <strong>return</strong> value;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> setValue(String value) {  </li>
<li>​        <strong>this</strong>.value = value;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> Original(String value) {  </li>
<li>​        <strong>this</strong>.value = value;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> Memento createMemento(){  </li>
<li>​        <strong>return</strong> <strong>new</strong> Memento(value);  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>void</strong> restoreMemento(Memento memento){  </li>
<li>​        <strong>this</strong>.value = memento.getValue();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Memento {  </li>
<li>​      </li>
<li>​    <strong>private</strong> String value;  </li>
<li></li>
<li>​    <strong>public</strong> Memento(String value) {  </li>
<li>​        <strong>this</strong>.value = value;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> String getValue() {  </li>
<li>​        <strong>return</strong> value;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> setValue(String value) {  </li>
<li>​        <strong>this</strong>.value = value;  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Storage {  </li>
<li>​      </li>
<li>​    <strong>private</strong> Memento memento;  </li>
<li>​      </li>
<li>​    <strong>public</strong> Storage(Memento memento) {  </li>
<li>​        <strong>this</strong>.memento = memento;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> Memento getMemento() {  </li>
<li>​        <strong>return</strong> memento;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> setMemento(Memento memento) {  </li>
<li>​        <strong>this</strong>.memento = memento;  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Test {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​          </li>
<li>​        // 创建原始类  </li>
<li>​        Original origi = <strong>new</strong> Original(“egg”);  </li>
<li></li>
<li>​        // 创建备忘录  </li>
<li>​        Storage storage = <strong>new</strong> Storage(origi.createMemento());  </li>
<li></li>
<li>​        // 修改原始类的状态  </li>
<li>​        System.out.println(“初始化状态为：” + origi.getValue());  </li>
<li>​        origi.setValue(“niu”);  </li>
<li>​        System.out.println(“修改后的状态为：” + origi.getValue());  </li>
<li></li>
<li>​        // 回复原始类的状态  </li>
<li>​        origi.restoreMemento(storage.getMemento());  </li>
<li>​        System.out.println(“恢复后的状态为：” + origi.getValue());  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出：</p>
<p>初始化状态为：egg<br>修改后的状态为：niu<br>恢复后的状态为：egg</p>
<p>简单描述下：新建原始类时，value被初始化为egg，后经过修改，将value的值置为niu，最后倒数第二行进行恢复状态，结果成功恢复了。其实我觉得这个模式叫“备份-恢复”模式最形象。</p>
<h4 id="20、状态模式（State）"><a href="#20、状态模式（State）" class="headerlink" title="20、状态模式（State）"></a>20、状态模式（State）</h4><p>核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。看图：</p>
<p><img src="/2019/04/20/设计模式/006156d2-f41f-3019-a194-b872a59ca426.jpg" alt="img"></p>
<p>State类是个状态类，Context类可以实现切换，我们来看看代码：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>package</strong> com.xtfggef.dp.state;  </li>
<li></li>
<li>/** </li>
<li>* 状态类的核心类 </li>
<li>* 2012-12-1 </li>
<li>* @author erqing </li>
<li>* </li>
<li>*/  </li>
<li><strong>public</strong> <strong>class</strong> State {  </li>
<li>​      </li>
<li>​    <strong>private</strong> String value;  </li>
<li>​      </li>
<li>​    <strong>public</strong> String getValue() {  </li>
<li>​        <strong>return</strong> value;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> setValue(String value) {  </li>
<li>​        <strong>this</strong>.value = value;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> method1(){  </li>
<li>​        System.out.println(“execute the first opt!”);  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>void</strong> method2(){  </li>
<li>​        System.out.println(“execute the second opt!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>package</strong> com.xtfggef.dp.state;  </li>
<li></li>
<li>/** </li>
<li>* 状态模式的切换类   2012-12-1 </li>
<li>* @author erqing </li>
<li>*  </li>
<li>*/  </li>
<li><strong>public</strong> <strong>class</strong> Context {  </li>
<li></li>
<li>​    <strong>private</strong> State state;  </li>
<li></li>
<li>​    <strong>public</strong> Context(State state) {  </li>
<li>​        <strong>this</strong>.state = state;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> State getState() {  </li>
<li>​        <strong>return</strong> state;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> setState(State state) {  </li>
<li>​        <strong>this</strong>.state = state;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>void</strong> method() {  </li>
<li>​        <strong>if</strong> (state.getValue().equals(“state1”)) {  </li>
<li>​            state.method1();  </li>
<li>​        } <strong>else</strong> <strong>if</strong> (state.getValue().equals(“state2”)) {  </li>
<li>​            state.method2();  </li>
<li>​        }  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Test {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​          </li>
<li>​        State state = <strong>new</strong> State();  </li>
<li>​        Context context = <strong>new</strong> Context(state);  </li>
<li>​          </li>
<li>​        //设置第一种状态  </li>
<li>​        state.setValue(“state1”);  </li>
<li>​        context.method();  </li>
<li>​          </li>
<li>​        //设置第二种状态  </li>
<li>​        state.setValue(“state2”);  </li>
<li>​        context.method();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出：</p>
<p>execute the first opt!<br>execute the second opt!</p>
<p>根据这个特性，状态模式在日常开发中用的挺多的，尤其是做网站的时候，我们有时希望根据对象的某一属性，区别开他们的一些功能，比如说简单的权限控制等。</p>
<h4 id="通过中间类"><a href="#通过中间类" class="headerlink" title="通过中间类"></a>通过中间类</h4><h4 id="21、访问者模式（Visitor）"><a href="#21、访问者模式（Visitor）" class="headerlink" title="21、访问者模式（Visitor）"></a>21、访问者模式（Visitor）</h4><p>访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。—— From 百科</p>
<p>简单来说，访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。简单关系图：</p>
<p><img src="/2019/04/20/设计模式/96bd38f3-2888-3cc5-b90f-0e7542dc5845.jpg" alt="img"></p>
<p>来看看原码：一个Visitor类，存放要访问的对象，</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Visitor {  </li>
<li>​    <strong>public</strong> <strong>void</strong> visit(Subject sub);  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> MyVisitor <strong>implements</strong> Visitor {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> visit(Subject sub) {  </li>
<li>​        System.out.println(“visit the subject：”+sub.getSubject());  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>Subject类，accept方法，接受将要访问它的对象，getSubject()获取将要被访问的属性，</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Subject {  </li>
<li>​    <strong>public</strong> <strong>void</strong> accept(Visitor visitor);  </li>
<li>​    <strong>public</strong> String getSubject();  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> MySubject <strong>implements</strong> Subject {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> accept(Visitor visitor) {  </li>
<li>​        visitor.visit(<strong>this</strong>);  </li>
<li>​    }  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> String getSubject() {  </li>
<li>​        <strong>return</strong> “love”;  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>测试：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Test {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​          </li>
<li>​        Visitor visitor = <strong>new</strong> MyVisitor();  </li>
<li>​        Subject sub = <strong>new</strong> MySubject();  </li>
<li>​        sub.accept(visitor);      </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出：visit the subject：love</p>
<p>该模式适用场景：如果我们想为一个现有的类增加新功能，不得不考虑几个事情：1、新功能会不会与现有功能出现兼容性问题？2、以后会不会再需要添加？3、如果类不允许修改代码怎么办？面对这些问题，最好的解决方法就是使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦，</p>
<h4 id="22、中介者模式（Mediator）"><a href="#22、中介者模式（Mediator）" class="headerlink" title="22、中介者模式（Mediator）"></a>22、中介者模式（Mediator）</h4><p>中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。先看看图：</p>
<p><img src="/2019/04/20/设计模式/f1f2cc36-ab27-32fa-9906-9cdee2c2b625.jpg" alt="img"></p>
<p>User类统一接口，User1和User2分别是不同的对象，二者之间有关联，如果不采用中介者模式，则需要二者相互持有引用，这样二者的耦合度很高，为了解耦，引入了Mediator类，提供统一接口，MyMediator为其实现类，里面持有User1和User2的实例，用来实现对User1和User2的控制。这样User1和User2两个对象相互独立，他们只需要保持好和Mediator之间的关系就行，剩下的全由MyMediator类来维护！基本实现：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Mediator {  </li>
<li>​    <strong>public</strong> <strong>void</strong> createMediator();  </li>
<li>​    <strong>public</strong> <strong>void</strong> workAll();  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> MyMediator <strong>implements</strong> Mediator {  </li>
<li></li>
<li>​    <strong>private</strong> User user1;  </li>
<li>​    <strong>private</strong> User user2;  </li>
<li>​      </li>
<li>​    <strong>public</strong> User getUser1() {  </li>
<li>​        <strong>return</strong> user1;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> User getUser2() {  </li>
<li>​        <strong>return</strong> user2;  </li>
<li>​    }  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> createMediator() {  </li>
<li>​        user1 = <strong>new</strong> User1(<strong>this</strong>);  </li>
<li>​        user2 = <strong>new</strong> User2(<strong>this</strong>);  </li>
<li>​    }  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> workAll() {  </li>
<li>​        user1.work();  </li>
<li>​        user2.work();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>abstract</strong> <strong>class</strong> User {  </li>
<li>​      </li>
<li>​    <strong>private</strong> Mediator mediator;  </li>
<li>​      </li>
<li>​    <strong>public</strong> Mediator getMediator(){  </li>
<li>​        <strong>return</strong> mediator;  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    <strong>public</strong> User(Mediator mediator) {  </li>
<li>​        <strong>this</strong>.mediator = mediator;  </li>
<li>​    }  </li>
<li></li>
<li>​    <strong>public</strong> <strong>abstract</strong> <strong>void</strong> work();  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> User1 <strong>extends</strong> User {  </li>
<li></li>
<li>​    <strong>public</strong> User1(Mediator mediator){  </li>
<li>​        <strong>super</strong>(mediator);  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> work() {  </li>
<li>​        System.out.println(“user1 exe!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> User2 <strong>extends</strong> User {  </li>
<li></li>
<li>​    <strong>public</strong> User2(Mediator mediator){  </li>
<li>​        <strong>super</strong>(mediator);  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>void</strong> work() {  </li>
<li>​        System.out.println(“user2 exe!”);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Test {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li>​        Mediator mediator = <strong>new</strong> MyMediator();  </li>
<li>​        mediator.createMediator();  </li>
<li>​        mediator.workAll();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>输出：</p>
<p>user1 exe!<br>user2 exe!</p>
<h4 id="23、解释器模式（Interpreter）"><a href="#23、解释器模式（Interpreter）" class="headerlink" title="23、解释器模式（Interpreter）"></a>23、解释器模式（Interpreter）</h4><p>解释器模式是我们暂时的最后一讲，一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。</p>
<p><img src="/2019/04/20/设计模式/c87e402e-a355-3761-9ce3-7978956ba475.jpg" alt="img"></p>
<p>Context类是一个上下文环境类，Plus和Minus分别是用来计算的实现，代码如下：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>interface</strong> Expression {  </li>
<li>​    <strong>public</strong> <strong>int</strong> interpret(Context context);  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Plus <strong>implements</strong> Expression {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>int</strong> interpret(Context context) {  </li>
<li>​        <strong>return</strong> context.getNum1()+context.getNum2();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Minus <strong>implements</strong> Expression {  </li>
<li></li>
<li>​    @Override  </li>
<li>​    <strong>public</strong> <strong>int</strong> interpret(Context context) {  </li>
<li>​        <strong>return</strong> context.getNum1()-context.getNum2();  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Context {  </li>
<li>​      </li>
<li>​    <strong>private</strong> <strong>int</strong> num1;  </li>
<li>​    <strong>private</strong> <strong>int</strong> num2;  </li>
<li>​      </li>
<li>​    <strong>public</strong> Context(<strong>int</strong> num1, <strong>int</strong> num2) {  </li>
<li>​        <strong>this</strong>.num1 = num1;  </li>
<li>​        <strong>this</strong>.num2 = num2;  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    <strong>public</strong> <strong>int</strong> getNum1() {  </li>
<li>​        <strong>return</strong> num1;  </li>
<li>​    }  </li>
<li>​    <strong>public</strong> <strong>void</strong> setNum1(<strong>int</strong> num1) {  </li>
<li>​        <strong>this</strong>.num1 = num1;  </li>
<li>​    }  </li>
<li>​    <strong>public</strong> <strong>int</strong> getNum2() {  </li>
<li>​        <strong>return</strong> num2;  </li>
<li>​    }  </li>
<li>​    <strong>public</strong> <strong>void</strong> setNum2(<strong>int</strong> num2) {  </li>
<li>​        <strong>this</strong>.num2 = num2;  </li>
<li>​    }  </li>
<li>​      </li>
<li>​      </li>
<li>}  </li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>class</strong> Test {  </li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li>
<li></li>
<li>​        // 计算9+2-8的值  </li>
<li>​        <strong>int</strong> result = <strong>new</strong> Minus().interpret((<strong>new</strong> Context(<strong>new</strong> Plus()  </li>
<li>​                .interpret(<strong>new</strong> Context(9, 2)), 8)));  </li>
<li>​        System.out.println(result);  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>最后输出正确的结果：3。</p>
<p>基本就这样，解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等！</p>
<h2 id="JavaScript-的面向对象"><a href="#JavaScript-的面向对象" class="headerlink" title="JavaScript 的面向对象"></a>JavaScript 的面向对象</h2><hr>
<h4 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h4><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>指同一操作作用于不同对象产生不同的执行效果。即将“做什么”和“谁去做怎么做”分开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let sound = function(anim)&#123;</span><br><span class="line">  if(anim instanceof Duck)&#123;</span><br><span class="line">    alert(&apos;ddd&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  if(anim instanceof Chicken)&#123;</span><br><span class="line">    alert(&apos;ccc)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let duck = new Duck()</span><br><span class="line">let ch = new Chicken()</span><br><span class="line">sound(duck) // &apos;ddd&apos;</span><br><span class="line">sound(ch) //&apos;ccc&apos;</span><br></pre></td></tr></table></figure>
<p>解除类型耦合，封装可变部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let sound = function(anim)&#123;</span><br><span class="line">  anim.sounds()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let Duck = function()&#123;&#125;</span><br><span class="line">Duck.prototype.sounds = function()&#123;</span><br><span class="line">  alert(&apos;ddd&apos;)</span><br><span class="line">&#125;</span><br><span class="line">sound(new Duck()) // &apos;ddd&apos;</span><br></pre></td></tr></table></figure>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>信息隐藏，外部无法直接访问该属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let myobj = (function()&#123;</span><br><span class="line">	let name = Symbol(&apos;myobj&apos;)</span><br><span class="line">  let obj = &#123;&#125;</span><br><span class="line">  obj[name] = &apos;demo&apos;</span><br><span class="line">  obj.getName = function()&#123;</span><br><span class="line">    return obj[name]</span><br><span class="line">  &#125;</span><br><span class="line">  return obj  </span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">alert(myobj.getName())</span><br></pre></td></tr></table></figure>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>js 使用原型链实现继承。</p>
<p>所有的对象都是从<code>Object.prototype</code> 克隆而来。如果对象对某一个操作无法响应，则会把该请求委托给构造器的原型，顺着原型链传递请求，直到有可以处理的对象为止。 </p>
<p>对象的  <code>_proto__</code> 指向构造器的原型对象即 <code>{constructor}.prototype</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;name:&apos;aaa&apos;&#125;</span><br><span class="line">let A = function()&#123;&#125;</span><br><span class="line">A.prototype = obj</span><br><span class="line">let a = new A()</span><br><span class="line">alert(a.name)</span><br></pre></td></tr></table></figure>
<ul>
<li>尝试遍历对象 a 的所有属性，没有 name 属性</li>
<li>查找 a 的构造器原型，<code>a.__proto__</code>指向 <code>A.prototype</code>，又被设置成 <code>obj</code></li>
<li>在 obj 对象找到 name 属性（如果此时也找不到，则为 undefined）</li>
</ul>
<h2 id="JavaScript-的设计模式"><a href="#JavaScript-的设计模式" class="headerlink" title="JavaScript 的设计模式"></a>JavaScript 的设计模式</h2><hr>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>指保证一个类只有一个实例，并提供一个访问它的全局访问点。</p>
<p>例如：全局对象 window、全局缓存、线程池等。</p>
<h5 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h5><p>使用一个变量标志当前是否存在该实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let Singleton = function(name)&#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line">Singleton.getInstance = (function()&#123;</span><br><span class="line">  let instance = null</span><br><span class="line">  return function(name)&#123;</span><br><span class="line">  	if(!instance)&#123;</span><br><span class="line">    	instance = new Singleton(name)</span><br><span class="line">  	&#125;</span><br><span class="line">  	return instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">let a = Singleton.getInstance(&apos;a&apos;)</span><br><span class="line">let b = Singleton.getInstance(&apos;b&apos;)</span><br><span class="line">a === b //true</span><br></pre></td></tr></table></figure>
<h5 id="代理实现"><a href="#代理实现" class="headerlink" title="代理实现"></a>代理实现</h5><p>实现单一职责。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let CreateDiv = function(html)&#123;</span><br><span class="line">  this.html = html</span><br><span class="line">  this.init()</span><br><span class="line">&#125;</span><br><span class="line">CreateDiv.prototype.init = function()&#123;</span><br><span class="line">  let div = document.createElement(&apos;div&apos;)</span><br><span class="line">  div.innerHTML = this.html</span><br><span class="line">  document.body.appendChild(div)</span><br><span class="line">&#125;</span><br><span class="line">let ProxyDiv = (function()&#123;</span><br><span class="line">  let instance = null</span><br><span class="line">  return function(html)&#123;</span><br><span class="line">    if(!instance)&#123;</span><br><span class="line">      instance = new CreateDiv(html)</span><br><span class="line">    &#125;</span><br><span class="line">    return instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h5 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a><strong>惰性单例</strong></h5><p>需要时才创建对象实例。</p>
<p>例如，登录模态框</p>
<ul>
<li>一是页面加载就创建，指定开始时隐藏，点击后显示；缺点是如果不登录浪费 dom 节点</li>
<li>二是点击后创建；缺点是，每次点击就创建一次</li>
<li>使用单例模式，点击后判断是否存在</li>
</ul>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>定义一系列算法并封装，这些算法可以互相替换。策略类封装具体的算法和计算过程；环境类接收请求并委托给某一个策略类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let strategies = &#123;</span><br><span class="line">  &apos;A&apos;:function(salary)&#123;</span><br><span class="line">    return salary * 4</span><br><span class="line">  &#125;,</span><br><span class="line">  &apos;S&apos;:function(salary)&#123;</span><br><span class="line"> 	 	return salary * 2</span><br><span class="line">	&#125;,</span><br><span class="line">  &apos;B&apos;:function(salary)&#123;</span><br><span class="line"> 	 	return salary * 6</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let calculateBonus = function(level,salary)&#123;</span><br><span class="line">  return strategies[level](salary)</span><br><span class="line">&#125;</span><br><span class="line">alert(calculateBonus(&apos;A&apos;,101))</span><br><span class="line"></span><br><span class="line">//高度概括</span><br><span class="line">let A = function(salary)&#123;</span><br><span class="line">    return salary * 4</span><br><span class="line">  &#125;</span><br><span class="line">alert(calculateBonus(A,100))  // 直接传入 fn</span><br></pre></td></tr></table></figure>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>指为一个对象提供一个代用品或者占位符，控制对它的访问。</p>
<h5 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h5><p>过滤某些请求操作，控制不同权限的访问。</p>
<h5 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h5><p>将开销大的操作延迟在合适时候进行操作。</p>
<p>例如图片预加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let myimg = (function()&#123;</span><br><span class="line">  let el = document.createElement(&apos;img&apos;)</span><br><span class="line">  document.body.appendChild(el)</span><br><span class="line">  </span><br><span class="line">  return &#123;</span><br><span class="line">    setSec:function(src)&#123;</span><br><span class="line">      el.src = src</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;)()</span><br><span class="line"> </span><br><span class="line"> let proxyImg = (function()&#123;</span><br><span class="line">   let img = new Image()</span><br><span class="line">   img.onLoad = function()&#123;</span><br><span class="line">     myimg.setSrc(this.src)</span><br><span class="line">   &#125;</span><br><span class="line">   return &#123;</span><br><span class="line">     setSrc:function(src)&#123;</span><br><span class="line">       myimg.setSrc(&apos;/loading.gif&apos;)</span><br><span class="line">       img.src = src</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)()</span><br><span class="line"> </span><br><span class="line"> proxyImg.setSrc(&apos;1.jpg&apos;)</span><br></pre></td></tr></table></figure>
<p>例如合并网络请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 点击后发送文件</span><br><span class="line">&lt;input type=&apos;checkbox&apos; id=&apos;1&apos;&gt;&lt;input&gt;</span><br><span class="line">&lt;input type=&apos;checkbox&apos; id=&apos;2&apos;&gt;&lt;input&gt;</span><br><span class="line">&lt;input type=&apos;checkbox&apos; id=&apos;3&apos;&gt;&lt;input&gt;</span><br><span class="line"></span><br><span class="line">//操作</span><br><span class="line">let syncFile = function(id)&#123;</span><br><span class="line">  console.log(&apos;开始同步文件的id为&apos; + id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let proxySyncFile = (function()&#123;</span><br><span class="line">  let cache = []   // 保存一段时间内需要同步的id</span><br><span class="line">  let timer = null  // 定时器</span><br><span class="line">  </span><br><span class="line">  return function(id)&#123;</span><br><span class="line">  	cache.push(id)</span><br><span class="line">  	if(timer) return;  //保证不覆盖已经启动的定时器</span><br><span class="line">  	timer = setTimeOut(function()&#123;</span><br><span class="line">      syncFile(cache.join(&apos;,&apos;))</span><br><span class="line">      clearTimeOut(timer)</span><br><span class="line">      timer = null</span><br><span class="line">      cache.length = 0</span><br><span class="line">  	&#125;,2000)  	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">let chcekboxs = document.getElementByTagName(&apos;input&apos;)</span><br><span class="line">for(let i = 0,c;c=checkboxs[i++];)&#123;</span><br><span class="line">  c.onclick=function()&#123;</span><br><span class="line">    if(this.checked===true)&#123;</span><br><span class="line">      proxySyncFile(this.id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="惰性加载"><a href="#惰性加载" class="headerlink" title="惰性加载"></a>惰性加载</h5><p>操作放在缓存队列，当真正需要使用时，遍历缓存队列进行操作。</p>
<h5 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h5><p>将操作开销大的结果进行缓存，下次调用的参数有的话直接返回上次的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let fn = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">let proxyFn = (function()&#123;</span><br><span class="line">  let cache = &#123;&#125;</span><br><span class="line">  return function()&#123;</span><br><span class="line">    let args = Array.prototype.join.call(arguments,&apos;,&apos;)</span><br><span class="line">    if(args in cache)&#123;</span><br><span class="line">      return cache[args]</span><br><span class="line">    &#125;</span><br><span class="line">    return cache[args] = fn.apply(null,arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p>指提供一种方式可以顺序访问一个聚合对象的各个元素，而不暴露该对象的内部表示。</p>
<h5 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h5><p>数组 forEach 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function forEach(arr,callback)&#123;</span><br><span class="line">  for(let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    callback.call(arr[i],i,arr[i],arr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">forEach([1,2,3],function(i,n)&#123;</span><br><span class="line">  alert([i,n])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>迭代器实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">	data:[&apos;aaa&apos;,&apos;bbb&apos;,&apos;ccc&apos;]</span><br><span class="line">  [Symbol.Iterator]:function()&#123;</span><br><span class="line">  	const self = this</span><br><span class="line">  	let index = 0</span><br><span class="line">    return &#123;    	</span><br><span class="line">      next:function()&#123;</span><br><span class="line">      	if(index&lt;self.data.length)&#123;</span><br><span class="line">          return &#123;</span><br><span class="line">          	value:self.data[index],</span><br><span class="line">          	done:false</span><br><span class="line">        	&#125;        	</span><br><span class="line">      	&#125;else&#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            value:undefind,</span><br><span class="line">            done:true</span><br><span class="line">          &#125;</span><br><span class="line">      	&#125;        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* iterEntries(obj)&#123;</span><br><span class="line">  let keys = Object.keys(obj)</span><br><span class="line">  for(let i =0;i&lt;keys.length;i++)&#123;</span><br><span class="line">    let key = key[i]</span><br><span class="line">    yield [key,obj[key]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myobj = &#123;foo:&apos;aaa&apos;,bar:&apos;bbb&apos;&#125;</span><br><span class="line"></span><br><span class="line">for(let [key,valvue] of iterEntries(myobj))&#123;</span><br><span class="line">  console.log(key,valye)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="内部迭代器"><a href="#内部迭代器" class="headerlink" title="内部迭代器"></a>内部迭代器</h5><p>内部定义迭代规则，外部只需调用一次</p>
<h5 id="外部迭代器"><a href="#外部迭代器" class="headerlink" title="外部迭代器"></a>外部迭代器</h5><p>外部显式请求调用下一个元素</p>
<p>简单实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let Iterator = function(arr)&#123;</span><br><span class="line">  let current = 0;</span><br><span class="line">  return &#123;</span><br><span class="line">    next:function()&#123;</span><br><span class="line">      current +=1</span><br><span class="line">    &#125;,</span><br><span class="line">    isDone:function()&#123;</span><br><span class="line">      return current &gt;= arr.length</span><br><span class="line">    &#125;,</span><br><span class="line">    getCurrItem;function()&#123;</span><br><span class="line">      return arr[current]</span><br><span class="line">    &#125;,</span><br><span class="line">    length:arr.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let iterator = Iterator([1,2,3,4])</span><br><span class="line">iterator.getCurrItem()</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.getCurrItem()</span><br></pre></td></tr></table></figure>
<h5 id="倒序迭代器"><a href="#倒序迭代器" class="headerlink" title="倒序迭代器"></a>倒序迭代器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function forEach(arr,callback)&#123;</span><br><span class="line">  for(let i=arr.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">    callback.call(arr[i],i,arr[i],arr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">forEach([1,2,3],function(i,n)&#123;</span><br><span class="line">  alert([i,n])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="中止迭代器"><a href="#中止迭代器" class="headerlink" title="中止迭代器"></a>中止迭代器</h5><p>提供跳出循环的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function forEach(arr,callback)&#123;</span><br><span class="line">  for(let i=arr.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">  	if(callback(i,arr[i],arr)===false) break;</span><br><span class="line">    callback.call(arr[i],i,arr[i],arr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发布-订阅模式（观察者模式）"><a href="#发布-订阅模式（观察者模式）" class="headerlink" title="发布-订阅模式（观察者模式）"></a>发布-订阅模式（观察者模式）</h4><p>指对象间的一对多的依赖关系，当一个对象的状态发生改变，所有依赖于它的对象都将得到通知。</p>
<p>降低对象间的强耦合。</p>
<p>可以应用于异步编程，替代传统回调函数；实际上，DOM 的绑定事件处理函数就是该模式。</p>
<h5 id="简单实现-1"><a href="#简单实现-1" class="headerlink" title="简单实现"></a>简单实现</h5><p>此时 listen 还是 myobj 触发，存在耦合；</p>
<p>每个发布者都有个缓存列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">let event = &#123;</span><br><span class="line">  clientList : [],</span><br><span class="line">  listen:function(key,fn)&#123;</span><br><span class="line">    if(!this.clientList[key])&#123;</span><br><span class="line">      this.clientList[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    this.clientList[key].push(fn)  // 缓存订阅消息</span><br><span class="line">  &#125;,</span><br><span class="line">  remove:function(key,fn)&#123;</span><br><span class="line">    let fns = this.clientList[key]</span><br><span class="line">    if(!fns) return false;    // 如果 key 对应消息没人订阅，直接返回</span><br><span class="line">    if(!fn) &#123;fns&amp;&amp;fns.length===0&#125; // 没有传入具体函数，默认删除所有订阅者</span><br><span class="line">    else&#123;</span><br><span class="line">      for(let i = fns.length-1;i&gt;=0;i--)&#123;  // 反向遍历</span><br><span class="line">        let _fn = fns[i]</span><br><span class="line">        if(_fn===fn)&#123;</span><br><span class="line">          fns.splice(i,1)  // 删除订阅者函数</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  trigger:function()&#123;</span><br><span class="line">    let key = Array.prototype.shift.call(arguments)</span><br><span class="line">    let fns = this.clientList[key]</span><br><span class="line">    if(!fns || fns.length ===0) return false;</span><br><span class="line">    for(let i=0,fn;fn=fns[i++];)&#123;</span><br><span class="line">      fn.apply(this,arguments)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 给对象添加订阅、发布的功能的函数</span><br><span class="line"></span><br><span class="line">let installEvent = function(obj)&#123;</span><br><span class="line">  for(let i in event)&#123;</span><br><span class="line">    obj[i] = event[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myobj = &#123;&#125;</span><br><span class="line">installEvent(myobj)</span><br><span class="line">myobj.listen(&apos;aaa&apos;,()=&gt;console.log(&apos;aaa&apos;))</span><br></pre></td></tr></table></figure>
<h5 id="全局订阅"><a href="#全局订阅" class="headerlink" title="全局订阅"></a>全局订阅</h5><p>使用全局 Event 解耦，只使用一个订阅者缓存队列</p>
<p>该方法可以实现<strong>模块间通信</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">let Event = (function()&#123;  </span><br><span class="line">  let clientList : []</span><br><span class="line">  let listen=function(key,fn)&#123;</span><br><span class="line">    if(!clientList[key])&#123;</span><br><span class="line">      clientList[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    clientList[key].push(fn)  // 缓存订阅消息</span><br><span class="line">  &#125;</span><br><span class="line">  let remove=function(key,fn)&#123;</span><br><span class="line">    let fns = clientList[key]</span><br><span class="line">    if(!fns) return false;    // 如果 key 对应消息没人订阅，直接返回</span><br><span class="line">    if(!fn) &#123;fns&amp;&amp;fns.length===0&#125; // 没有传入具体函数，默认删除所有订阅者</span><br><span class="line">    else&#123;</span><br><span class="line">      for(let i = fns.length-1;i&gt;=0;i--)&#123;  // 反向遍历</span><br><span class="line">        let _fn = fns[i]</span><br><span class="line">        if(_fn===fn)&#123;</span><br><span class="line">          fns.splice(i,1)  // 删除订阅者函数</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">  let trigger=function()&#123;</span><br><span class="line">    let key = Array.prototype.shift.call(arguments)</span><br><span class="line">    let fns = clientList[key]</span><br><span class="line">    if(!fns || fns.length ===0) return false;</span><br><span class="line">    for(let i=0,fn;fn=fns[i++];)&#123;</span><br><span class="line">      fn.apply(this,arguments)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  return &#123;</span><br><span class="line">    listen,</span><br><span class="line">    trigger,</span><br><span class="line">    remove</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">Event.listen(&apos;aaa&apos;,(price)=&gt;&#123;</span><br><span class="line">  console.log(&apos;aaa&apos;+price)</span><br><span class="line">&#125;)</span><br><span class="line">Event.trigger(&apos;aaa&apos;,111)</span><br></pre></td></tr></table></figure>
<h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>全局一个缓冲队列会出现事件名冲突；可以使用命名空间解决。</p>
<h5 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布-订阅"></a>发布-订阅</h5><p>上述都是必须订阅者先订阅消息，然后才能接受发布的消息。</p>
<p>某些情况下需要先保存发布的消息，再等有对象订阅时发布，如QQ离线消息。</p>
<p>可以建立存放离线事件的堆栈，没有订阅者时先放入包装函数，等到有订阅者时遍历堆栈依次执行离线事件。</p>
<p>注意该离线事件生命周期，大部分情况下只要执行一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">let Event = (function()&#123;  </span><br><span class="line">	let global = this </span><br><span class="line">	let _default = &apos;default&apos;</span><br><span class="line">	let Event = function()&#123;</span><br><span class="line">		let namespaceCache = &#123;&#125;</span><br><span class="line">		</span><br><span class="line">    let _slice = Array.prototype.slice</span><br><span class="line">    let _shift =  Array.prototype.shift</span><br><span class="line">    let _unshift =  Array.prototype.unshift</span><br><span class="line">    let each = function(arr,fn)&#123;</span><br><span class="line">      let ret = null</span><br><span class="line">      for(let i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        let n = arr[i]</span><br><span class="line">        ret = fn.call(n,i,n)</span><br><span class="line">      &#125;</span><br><span class="line">      return ret6</span><br><span class="line">    &#125;</span><br><span class="line">		let _listen = function(key,fn,cache)&#123;</span><br><span class="line">			if(!cache[key])&#123;</span><br><span class="line">        cache[key] = []</span><br><span class="line">			&#125;      </span><br><span class="line">			cache[key].push(fn)</span><br><span class="line">		&#125;</span><br><span class="line">    let _remove = function（key,fn,cache）&#123;</span><br><span class="line">      if(cache[key])&#123;</span><br><span class="line">        if(fn)&#123;</span><br><span class="line">          for(var i=cache[key].length;i&gt;=0;i--)&#123;</span><br><span class="line">            if(cache[key][i]===fn)&#123;</span><br><span class="line">              cache[key].splice(i,1)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          cache[key]=[]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let _trigger = function()&#123;</span><br><span class="line">      let cache = _shift.call(arguments)</span><br><span class="line">      let key = _shift.call(arguments)</span><br><span class="line">      let args = arguments</span><br><span class="line">      _self = this</span><br><span class="line">      let stack = cache[key]</span><br><span class="line">      if(!stack||!stack.length) return;</span><br><span class="line">      return each(stack,function()&#123;</span><br><span class="line">        return this.apply(_self,args)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;    </span><br><span class="line">	&#125;</span><br><span class="line">	let _create = function(namespace=&apos;default&apos;)&#123;</span><br><span class="line">    let cache = &#123;&#125;</span><br><span class="line">    let offlineStack = []</span><br><span class="line">    let ret = &#123;</span><br><span class="line">      listen:function(key,fn,last)&#123;</span><br><span class="line">        _listen(key,fn,cache)</span><br><span class="line">        if(offlineStack===null) return;</span><br><span class="line">        if(last===&apos;last&apos;)&#123;</span><br><span class="line">          offlineStack.length &amp;&amp; offlineStack.pop()</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          each(offlineStack,function()&#123;</span><br><span class="line">            this()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        offlineStack = null</span><br><span class="line">      &#125;,</span><br><span class="line">      one:function(key,fn,last)&#123;</span><br><span class="line">        _remove(key,cache)</span><br><span class="line">        this.listen(key,fn,last)</span><br><span class="line">      &#125;,</span><br><span class="line">      remove:function(key,fn)&#123;</span><br><span class="line">        _remove(key,cache,fn)</span><br><span class="line">      &#125;,</span><br><span class="line">      trigger:function()&#123;</span><br><span class="line">        let _self = this</span><br><span class="line">        let args = arguments</span><br><span class="line">        let fn = function()&#123;</span><br><span class="line">          return _trigger.apply(_self,args)</span><br><span class="line">        &#125;</span><br><span class="line">        _unshift.call(arguments,cache)</span><br><span class="line">        if(offlineStack)&#123;</span><br><span class="line">          return offlineStack.push(fn)</span><br><span class="line">        &#125;</span><br><span class="line">        return fn()</span><br><span class="line">      &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return namespace?</span><br><span class="line">    	(namespaceCache[namespace]?namespaceCache[namespace]:</span><br><span class="line">    		namespaceCache[namespace]=ret)</span><br><span class="line">    			:ret    </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return &#123;</span><br><span class="line">    create:_create,</span><br><span class="line">    one:function(key,fn,last)&#123;</span><br><span class="line">      let event = this.create()</span><br><span class="line">      event.one(key,fn,last)</span><br><span class="line">    &#125;,</span><br><span class="line">    remove:function(key,fn)&#123;</span><br><span class="line">      let event = this.create()</span><br><span class="line">      event.remove(key,fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    listen:function(key,fn,last)&#123;</span><br><span class="line">      let event = this.create()</span><br><span class="line">      event.listen(key,fn,last)</span><br><span class="line">    &#125;,</span><br><span class="line">    trigger:function()&#123;</span><br><span class="line">      let event = this.create()</span><br><span class="line">      event.trigger.apply(this,arguments)</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 先发布后订阅</span><br><span class="line">Event.trigger(&apos;click&apos;,1)</span><br><span class="line">Event.listen(&apos;click&apos;,console.log(&apos;aa&apos;))</span><br><span class="line"></span><br><span class="line">// 使用命名空间</span><br><span class="line">Event.create(&apos;namespace02&apos;).listen(&apos;click&apos;,console.log(&apos;aaa&apos;))</span><br><span class="line">Event.create(&apos;namespace02&apos;).trigger(&apos;click&apos;,2)</span><br></pre></td></tr></table></figure>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>使用场景：有时需要向某些对象发送请求，但不知道接受者是谁，也不知道被请求的操作。松耦合的方式。</p>
<p>可以将请求封装成命令对象，传递命令对象解除耦合；可以实现延时、撤销、排队等。</p>
<p>常见使用是菜单程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let RefreshCommand = function(receiver)&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    execute:function()&#123;</span><br><span class="line">      receiver.refresh()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let setCommand = function(button,command)&#123;</span><br><span class="line">  button.onclick = function()&#123;</span><br><span class="line">    command.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let MenuBar = &#123;</span><br><span class="line">  refresh:function()&#123;</span><br><span class="line">    console.log(&apos;refresh&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let refreshCom = RefreshCommand(MenuBar)</span><br><span class="line">setCommand(btn1,refreshCom)</span><br></pre></td></tr></table></figure>
<h5 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h5><ul>
<li>执行命令时记录上次的命令位置等信息，提供 undo 方法实现撤销操作；</li>
<li>如果是撤销一系列操作，可以将所有命令存储在历史列表，倒序循环操作；</li>
<li>某些情况下如画图无法实现 undo ，可以清除信息，顺序执行历史命令。即<strong>播放</strong>功能。</li>
</ul>
<h5 id="命令队列"><a href="#命令队列" class="headerlink" title="命令队列"></a>命令队列</h5><p>封装命令对象存入队列，使用回调函数或者发布订阅，执行队列。</p>
<h5 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let MacroCommand = function()&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">  	commandList:[],</span><br><span class="line">    add:function(command)&#123;this.commandList.push(command)&#125;</span><br><span class="line">    execute:function()&#123;this.commandList.forEach((index,item)=&gt;item.execute())&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><p>指将对象组合成树结构，表示“部分-整体”的层次结构。另一个好处是通过对象的多态性表现，使得组合对象和单个对象的使用具有一致性。</p>
<p>由于是树结构，在进行操作时，如果是叶节点，直接执行；如果是节点，继续操作。每次对最上层对象请求，实际上对整个树进行深度优先搜索。</p>
<p>例如，上述宏命令不仅可以加入微任务，还可以<strong>嵌套</strong>宏命令，或者引用<strong>父级</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let Command = function()&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">  	parent:null,   //父级元素</span><br><span class="line">    add:function()&#123;throw new Error(&apos;叶节点无法添加子命令&apos;)&#125;   // 接口一致性</span><br><span class="line">    execute:function()&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组合模式常见实例是文件夹操作。</p>
<p>注意：</p>
<ul>
<li>组合模式不是父子关系。是 HAS-A 而不是 IS-A。</li>
<li>叶操作一致性。组合对象和叶对象有相同的接口（如上述 add ），且必须是对一组叶对象（不能是对部分对象）的操作。</li>
<li>双向映射关系。某个对象不能有两个以上不同的节点，否则可能会出现操作多次。</li>
</ul>
<h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p>使用继承即可实现的简单的模式。</p>
<p>模板方法模式由抽象父类和具体子类构成。抽象父类封装子类的算法框架，包括公共方法和执行顺序；具体子类继承抽象类，可以选择重写父类方法。</p>
<p>使用场景多为搭建项目架构，如 <code>httpservlet</code> 框架。</p>
<p>举例，冲泡咖啡和茶叶。</p>
<p>此处模板方法为 <code>Beverage.prototype.init</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let Beverage = function()&#123;&#125;</span><br><span class="line">Beverage.prototype.boilWater=function()&#123;&#125;</span><br><span class="line">Beverage.prototype.putIntoCup=function()&#123;&#125;</span><br><span class="line">Beverage.prototype.init=function()&#123;</span><br><span class="line">  this.boilWater()</span><br><span class="line">  this.putIntoCup()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let Coffeee = function()&#123;&#125;</span><br><span class="line">Coffee.prototype = new Beverage()</span><br></pre></td></tr></table></figure>
<h5 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h5><p>允许个性化操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Beverage.prototype.needWater=function()&#123;return true&#125;</span><br><span class="line">Beverage.prototype.init=function()&#123;</span><br><span class="line">	if(this.needWater())&#123;</span><br><span class="line">     this.boilWater()</span><br><span class="line">	&#125;</span><br><span class="line">  this.putIntoCup()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="不使用继承"><a href="#不使用继承" class="headerlink" title="不使用继承"></a>不使用继承</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let Beverage = function(params)&#123;</span><br><span class="line">  let boilWater=params.boilWater||function()&#123;&#125;</span><br><span class="line">  let putIntoCup=function()&#123;&#125;</span><br><span class="line">  let F = function()&#123;&#125;</span><br><span class="line">  F.prototype.init=function()&#123;</span><br><span class="line">  	boilWater()</span><br><span class="line">  	putIntoCup()</span><br><span class="line">	&#125;</span><br><span class="line">	return F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let Coffeee =Beverage(&#123;</span><br><span class="line">  boilWater:function()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>运用共享技术有效支持大量细粒度的对象，可以有效地进行性能优化。</p>
<p>享元模式要求对象属性划分为内部状态（属性）和外部状态。</p>
<ul>
<li>内部状态存储于对象内部</li>
<li>内部状态可以被一些对象共享</li>
<li>内部状态独立于具体场景，通常不会改变</li>
<li>外部状态取决于具体场景，不能被共享</li>
</ul>
<p>使用场景：</p>
<ul>
<li>大量相似对象以及因此造成很大内存开销</li>
<li>对象的大多数状态可以变为外部状态</li>
<li>剥离外部状态，可以用较小对象取代大量对象</li>
</ul>
<h5 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h5><p>维护装载空闲对象的池子，如果需要对象时，不直接创建对象，而是转从对象池获取。</p>
<p>例如 HTTP 连接池、数据库连接池 以及 DOM 相关操作。</p>
<p>通用对象池的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h4><p>使多个对象都有机会处理请求，避免请求发送者和接受者之间耦合关系；请求沿对象链传递，直到被一个对象处理。</p>
<h5 id="简单实现-2"><a href="#简单实现-2" class="headerlink" title="简单实现"></a>简单实现</h5><p>例如处理订单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 定义订单</span><br><span class="line">let order500 = function(type,payed,stock)&#123;</span><br><span class="line">  if(type===1 &amp;&amp; payed===true)&#123;</span><br><span class="line">    console.log(&apos;支付500，高级会员购买成功&apos;)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return &apos;nextSuccessor&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let order200 = function(type,payed,stock)&#123;</span><br><span class="line">  if(type===2 &amp;&amp; payed===true)&#123;</span><br><span class="line">    console.log(&apos;支付200，会员购买成功&apos;)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return &apos;nextSuccessor&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let orderNormal = function(type,payed,stock)&#123;</span><br><span class="line">  if(stock&gt;0)&#123;</span><br><span class="line">    console.log(&apos;普通订单&apos;)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">     console.log(&apos;库存不足&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义职责连</span><br><span class="line">let Chain = function(fn)&#123;</span><br><span class="line">  this.fn = fn</span><br><span class="line">  this.successor = null</span><br><span class="line">&#125;</span><br><span class="line">Chain.prototype.setNextSuccessor = function(successor)&#123;</span><br><span class="line">  return this.successor = successor</span><br><span class="line">&#125;</span><br><span class="line">Chain.prototype.passRequest = function()&#123;</span><br><span class="line">	let ret = this.fn.apply(this,arguments)</span><br><span class="line">	if(ret===&apos;nextSuccessor&apos;)&#123;</span><br><span class="line">    return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor,arguments)</span><br><span class="line">	&#125;</span><br><span class="line">  return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 包装职责连</span><br><span class="line">let chain500 = new Chain(order500)</span><br><span class="line">let chain200 = new Chain(order200)</span><br><span class="line">let chainNormal = new Chain(orderNormal)</span><br><span class="line"></span><br><span class="line">chain500.setNextSuccessor(chain200)</span><br><span class="line">chain200.setNextSuccessor(chainNormal)</span><br><span class="line"></span><br><span class="line">chain500.passRequest(2,true,500)</span><br></pre></td></tr></table></figure>
<h5 id="AOP-职责连"><a href="#AOP-职责连" class="headerlink" title="AOP 职责连"></a>AOP 职责连</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.after = function(fn)&#123;</span><br><span class="line">  let self=this</span><br><span class="line">  return function()&#123;</span><br><span class="line">    let ret = self.apply(this,arguments)</span><br><span class="line">    if(ret===&apos;nextSuccessor&apos;)&#123;</span><br><span class="line">      return fn.apply(this,arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    return ret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let order = order500.after(order200).after(orderNormal)</span><br><span class="line">order(2,true,500)</span><br></pre></td></tr></table></figure>
<h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><p>增加中介者，解除对象间互相引用的耦合，使得对象间网状结构变成相对简单的一对多关系。</p>
<p>现实生活如机场指挥塔等等。</p>
<p>实现方式有些像 发布-订阅模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let manager = (function()&#123;</span><br><span class="line">  let players = &#123;&#125; // 保存玩家</span><br><span class="line">  let operations = &#123;&#125; // 中介者可执行操作</span><br><span class="line">  </span><br><span class="line">  operations.addPlayer = function()&#123;&#125;</span><br><span class="line">  operations.removePalyer = function()&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  let receiveMsg = function()&#123;</span><br><span class="line">    let msg = Array.prototype.shift.call(arguments)</span><br><span class="line">    operations[msg].apply(this,arguments)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return &#123;</span><br><span class="line">    receiveMsg</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">let player = &#123;</span><br><span class="line">  create：function()&#123;</span><br><span class="line">    //...</span><br><span class="line">    manager.receiveMsg(&apos;addPlayer&apos;,this,obj)  // 类似这种，只是举例</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p>动态给某个对象添加额外的功能而不影响这个类派生的其他对象。</p>
<p>使用继承会暴露超类内部细节，同时子类和超类强耦合，子类随着超类一起改变。</p>
<h5 id="AOP实现"><a href="#AOP实现" class="headerlink" title="AOP实现"></a>AOP实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// beforeFn 在 fn 前执行</span><br><span class="line">Function.prototype.before=function(beforeFn)&#123;</span><br><span class="line">  let self = this</span><br><span class="line">  return function()&#123;</span><br><span class="line">    beforeFn.apply(this,arguments)</span><br><span class="line">    return self.apply(this,arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// afterFn 在 fn 后执行</span><br><span class="line">Function.prototype.after=function(afterFn)&#123;</span><br><span class="line">  let self = this</span><br><span class="line">  return function()&#123;</span><br><span class="line">  	let ret = self.apply(this,arguments)</span><br><span class="line">    afterFn.apply(this,arguments)</span><br><span class="line">    return ret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">let before=function(fn,beforeFn)&#123;</span><br><span class="line">  return function()&#123;</span><br><span class="line">    beforeFn.apply(this,arguments)</span><br><span class="line">    return fn.apply(this,arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p>允许一个对象在其内部状态改变时改变其行为。该模式关键是区分事物内部状态，状态的改变往往会带来事物行为的改变</p>
<h5 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h5><p>以开关灯举例</p>
<p>每个状态都有自己的类，切换规则事先在状态类内，消除条件分支语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let WeakState = function(light)&#123;</span><br><span class="line">	this.light = light  </span><br><span class="line">&#125;</span><br><span class="line">WeakState.prototype.btnPressed = function()&#123;</span><br><span class="line">  console.log(&apos;weak&apos;)</span><br><span class="line">  this.light.setState(this.light.strongState)</span><br><span class="line">&#125;</span><br><span class="line">let Light = function()&#123;</span><br><span class="line">  thi.offState = new OffState(this)</span><br><span class="line">  this.strongState = new StrongState(this)</span><br><span class="line">  this.weakState = new WeakState(this)</span><br><span class="line">  this.button = null</span><br><span class="line">&#125;</span><br><span class="line">Light.prototype.init = function()&#123;</span><br><span class="line">	let self = this</span><br><span class="line">  this.button = $(&apos;btn&apos;)</span><br><span class="line">  this.currState = this.offState</span><br><span class="line">  this.button.onclick = function()&#123;</span><br><span class="line">    self.currState.btnPressed()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Light.prototype.setState = function(state)&#123;</span><br><span class="line">  this.currState = state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化：</p>
<ul>
<li>有两种创建 state 对象的方法：需要时创建和一开始直接创建。</li>
<li>state 对象可以使用享元模式共享。</li>
</ul>
<h5 id="JS-版本状态机"><a href="#JS-版本状态机" class="headerlink" title="JS 版本状态机"></a>JS 版本状态机</h5><blockquote>
<p><a href="https://github.com/jakesgordon/javascript-state-machine" target="_blank" rel="noopener">表驱动的有限状态机</a></p>
</blockquote>
<p>状态对象不一定是单独的类，可以进行请求委托到对象字面量，将变量保存为对象的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let FSM = &#123;</span><br><span class="line">  on:&#123;</span><br><span class="line">    btnPressed:function()&#123;</span><br><span class="line">      //...</span><br><span class="line">      this.currState = FSM.off</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  off:&#123;</span><br><span class="line">  	btnPressed:function()&#123;</span><br><span class="line">    	//...</span><br><span class="line">    	this.currState = FSM.on</span><br><span class="line"> 	 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let Light = function()&#123;</span><br><span class="line">  this.currState = FSM.off</span><br><span class="line">  this.btn = null</span><br><span class="line">&#125;</span><br><span class="line">Light.prototype.init=function()&#123;</span><br><span class="line">	let self = this</span><br><span class="line">  this.btn = $(&apos;btn&apos;)</span><br><span class="line">  this.btn.click = function()&#123;</span><br><span class="line">    self.currState.btnPressed.call(self)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步的，闭包实现，变量封闭在闭包环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function delegate(ctx,delegation)&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    btnPressed:function&#123;</span><br><span class="line">      return delegation.btnPressed.apply(ctx,arguments)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let FSM = &#123;</span><br><span class="line">  on:&#123;</span><br><span class="line">    btnPressed:function()&#123;</span><br><span class="line">      //...</span><br><span class="line">      this.currState = this.offState</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  off:&#123;</span><br><span class="line">  	btnPressed:function()&#123;</span><br><span class="line">    	//...</span><br><span class="line">    	this.currState = this.onState</span><br><span class="line"> 	 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let Light = function()&#123;</span><br><span class="line">  this.currState = this.offState // 初始状态</span><br><span class="line">  this.offState = delegate(this,FSM.off)</span><br><span class="line">  this.onState = delegate(this,FSM.on)</span><br><span class="line">  this.btn = null</span><br><span class="line">&#125;</span><br><span class="line">Light.prototype.init=function()&#123;</span><br><span class="line">	let self = this</span><br><span class="line">  this.btn = $(&apos;btn&apos;)</span><br><span class="line">  this.btn.click = function()&#123;</span><br><span class="line">    self.currState.btnPressed()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>解决接口不兼容问题，将原接口转换成可以使用的接口。</p>

      
    </div>
    
    
    
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    

    

    


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/设计模式/" rel="tag"><i class="fa fa-tag"></i> 设计模式</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/17/面试题/" rel="next" title="面试题">
                <i class="fa fa-chevron-left"></i> 面试题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/22/html5新增/html/" rel="prev" title="node 服务器">
                node 服务器 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/album.jpg" alt="Xiao Qi">
            
              <p class="site-author-name" itemprop="name">Xiao Qi</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/qiwang97" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2396586732@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                推荐阅读
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.liaoxuefeng.com/" title="廖雪峰" target="_blank">廖雪峰</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.alloyteam.com/nav/" title="Web前端导航" target="_blank">Web前端导航</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#设计模式的六大原则"><span class="nav-number">1.</span> <span class="nav-text">设计模式的六大原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总原则：开闭原则（Open-Close-Principle）"><span class="nav-number">1.0.1.</span> <span class="nav-text">总原则：开闭原则（Open Close Principle）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单一职责原则"><span class="nav-number">1.0.2.</span> <span class="nav-text">单一职责原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#里氏替换原则（Liskov-Substitution-Principle）"><span class="nav-number">1.0.3.</span> <span class="nav-text">里氏替换原则（Liskov Substitution Principle）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#依赖倒转原则（Dependence-Inversion-Principle）"><span class="nav-number">1.0.4.</span> <span class="nav-text">依赖倒转原则（Dependence Inversion Principle）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口隔离原则（Interface-Segregation-Principle）"><span class="nav-number">1.0.5.</span> <span class="nav-text">接口隔离原则（Interface Segregation Principle）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迪米特法则（最少知道原则）（Demeter-Principle）"><span class="nav-number">1.0.6.</span> <span class="nav-text">迪米特法则（最少知道原则）（Demeter Principle）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合成复用原则（Composite-Reuse-Principle）"><span class="nav-number">1.0.7.</span> <span class="nav-text">合成复用原则（Composite Reuse Principle）</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#设计模式"><span class="nav-number">2.</span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的23中设计模式"><span class="nav-number">3.</span> <span class="nav-text">Java的23中设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建模式"><span class="nav-number">3.1.</span> <span class="nav-text">创建模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0、简单工厂模式"><span class="nav-number">3.1.1.</span> <span class="nav-text">0、简单工厂模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#01、普通"><span class="nav-number">3.1.2.</span> <span class="nav-text">01、普通</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#02、多个方法"><span class="nav-number">3.1.3.</span> <span class="nav-text">02、多个方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#03、多个静态方法"><span class="nav-number">3.1.4.</span> <span class="nav-text">03、多个静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1、工厂方法模式（Factory-Method）"><span class="nav-number">3.1.5.</span> <span class="nav-text">1、工厂方法模式（Factory Method）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、抽象工厂模式"><span class="nav-number">3.1.6.</span> <span class="nav-text">2、抽象工厂模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、单例模式（Singleton）"><span class="nav-number">3.1.7.</span> <span class="nav-text">3、单例模式（Singleton）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、建造者模式（Builder）"><span class="nav-number">3.1.8.</span> <span class="nav-text">4、建造者模式（Builder）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、原型模式（Prototype）"><span class="nav-number">3.1.9.</span> <span class="nav-text">5、原型模式（Prototype）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#"><span class="nav-number">3.1.10.</span> <span class="nav-text">}</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构模式（7种）"><span class="nav-number">3.2.</span> <span class="nav-text">结构模式（7种）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6、适配器模式"><span class="nav-number">3.2.1.</span> <span class="nav-text">6、适配器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#01、类的适配器模式"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">01、类的适配器模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#02、对象的适配器模式"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">02、对象的适配器模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#03、接口的适配器模式"><span class="nav-number">3.2.2.</span> <span class="nav-text">03、接口的适配器模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7、装饰模式（Decorator）"><span class="nav-number">3.2.3.</span> <span class="nav-text">7、装饰模式（Decorator）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8、代理模式（Proxy）"><span class="nav-number">3.2.4.</span> <span class="nav-text">8、代理模式（Proxy）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9、外观模式（Facade）"><span class="nav-number">3.2.5.</span> <span class="nav-text">9、外观模式（Facade）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10、桥接模式（Bridge）"><span class="nav-number">3.2.6.</span> <span class="nav-text">10、桥接模式（Bridge）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11、组合模式（Composite）"><span class="nav-number">3.2.7.</span> <span class="nav-text">11、组合模式（Composite）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系模式（11种）"><span class="nav-number">3.3.</span> <span class="nav-text">关系模式（11种）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#父类与子类关系"><span class="nav-number">3.3.1.</span> <span class="nav-text">父类与子类关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13、策略模式（strategy）"><span class="nav-number">3.3.2.</span> <span class="nav-text">13、策略模式（strategy）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14、模板方法模式（Template-Method）"><span class="nav-number">3.3.3.</span> <span class="nav-text">14、模板方法模式（Template Method）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类之间的关系"><span class="nav-number">3.3.4.</span> <span class="nav-text">类之间的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15、观察者模式（Observer）"><span class="nav-number">3.3.5.</span> <span class="nav-text">15、观察者模式（Observer）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16、迭代子模式（Iterator）"><span class="nav-number">3.3.6.</span> <span class="nav-text">16、迭代子模式（Iterator）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17、责任链模式（Chain-of-Responsibility）"><span class="nav-number">3.3.7.</span> <span class="nav-text">17、责任链模式（Chain of Responsibility）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18、命令模式（Command）"><span class="nav-number">3.3.8.</span> <span class="nav-text">18、命令模式（Command）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码："><span class="nav-number">3.3.9.</span> <span class="nav-text">Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类的状态"><span class="nav-number">3.3.10.</span> <span class="nav-text">类的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19、备忘录模式（Memento）"><span class="nav-number">3.3.11.</span> <span class="nav-text">19、备忘录模式（Memento）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20、状态模式（State）"><span class="nav-number">3.3.12.</span> <span class="nav-text">20、状态模式（State）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过中间类"><span class="nav-number">3.3.13.</span> <span class="nav-text">通过中间类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21、访问者模式（Visitor）"><span class="nav-number">3.3.14.</span> <span class="nav-text">21、访问者模式（Visitor）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22、中介者模式（Mediator）"><span class="nav-number">3.3.15.</span> <span class="nav-text">22、中介者模式（Mediator）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23、解释器模式（Interpreter）"><span class="nav-number">3.3.16.</span> <span class="nav-text">23、解释器模式（Interpreter）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-的面向对象"><span class="nav-number">4.</span> <span class="nav-text">JavaScript 的面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态类型"><span class="nav-number">4.0.1.</span> <span class="nav-text">动态类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态"><span class="nav-number">4.0.2.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#封装"><span class="nav-number">4.0.3.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承"><span class="nav-number">4.0.4.</span> <span class="nav-text">继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-的设计模式"><span class="nav-number">5.</span> <span class="nav-text">JavaScript 的设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单例模式"><span class="nav-number">5.0.1.</span> <span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简单实现"><span class="nav-number">5.0.1.1.</span> <span class="nav-text">简单实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代理实现"><span class="nav-number">5.0.1.2.</span> <span class="nav-text">代理实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#惰性单例"><span class="nav-number">5.0.1.3.</span> <span class="nav-text">惰性单例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#策略模式"><span class="nav-number">5.0.2.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代理模式"><span class="nav-number">5.0.3.</span> <span class="nav-text">代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#保护代理"><span class="nav-number">5.0.3.1.</span> <span class="nav-text">保护代理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#虚拟代理"><span class="nav-number">5.0.3.2.</span> <span class="nav-text">虚拟代理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#惰性加载"><span class="nav-number">5.0.3.3.</span> <span class="nav-text">惰性加载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缓存代理"><span class="nav-number">5.0.3.4.</span> <span class="nav-text">缓存代理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器模式"><span class="nav-number">5.0.4.</span> <span class="nav-text">迭代器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#迭代器实现"><span class="nav-number">5.0.4.1.</span> <span class="nav-text">迭代器实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内部迭代器"><span class="nav-number">5.0.4.2.</span> <span class="nav-text">内部迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#外部迭代器"><span class="nav-number">5.0.4.3.</span> <span class="nav-text">外部迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#倒序迭代器"><span class="nav-number">5.0.4.4.</span> <span class="nav-text">倒序迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#中止迭代器"><span class="nav-number">5.0.4.5.</span> <span class="nav-text">中止迭代器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发布-订阅模式（观察者模式）"><span class="nav-number">5.0.5.</span> <span class="nav-text">发布-订阅模式（观察者模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简单实现-1"><span class="nav-number">5.0.5.1.</span> <span class="nav-text">简单实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#全局订阅"><span class="nav-number">5.0.5.2.</span> <span class="nav-text">全局订阅</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#命名空间"><span class="nav-number">5.0.5.3.</span> <span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#发布-订阅"><span class="nav-number">5.0.5.4.</span> <span class="nav-text">发布-订阅</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命令模式"><span class="nav-number">5.0.6.</span> <span class="nav-text">命令模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#撤销"><span class="nav-number">5.0.6.1.</span> <span class="nav-text">撤销</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#命令队列"><span class="nav-number">5.0.6.2.</span> <span class="nav-text">命令队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#宏命令"><span class="nav-number">5.0.6.3.</span> <span class="nav-text">宏命令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组合模式"><span class="nav-number">5.0.7.</span> <span class="nav-text">组合模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模板方法模式"><span class="nav-number">5.0.8.</span> <span class="nav-text">模板方法模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#钩子方法"><span class="nav-number">5.0.8.1.</span> <span class="nav-text">钩子方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#不使用继承"><span class="nav-number">5.0.8.2.</span> <span class="nav-text">不使用继承</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#享元模式"><span class="nav-number">5.0.9.</span> <span class="nav-text">享元模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对象池"><span class="nav-number">5.0.9.1.</span> <span class="nav-text">对象池</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#职责链模式"><span class="nav-number">5.0.10.</span> <span class="nav-text">职责链模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简单实现-2"><span class="nav-number">5.0.10.1.</span> <span class="nav-text">简单实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AOP-职责连"><span class="nav-number">5.0.10.2.</span> <span class="nav-text">AOP 职责连</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中介者模式"><span class="nav-number">5.0.11.</span> <span class="nav-text">中介者模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装饰者模式"><span class="nav-number">5.0.12.</span> <span class="nav-text">装饰者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AOP实现"><span class="nav-number">5.0.12.1.</span> <span class="nav-text">AOP实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#状态模式"><span class="nav-number">5.0.13.</span> <span class="nav-text">状态模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本实现"><span class="nav-number">5.0.13.1.</span> <span class="nav-text">基本实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JS-版本状态机"><span class="nav-number">5.0.13.2.</span> <span class="nav-text">JS 版本状态机</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#适配器模式"><span class="nav-number">5.0.14.</span> <span class="nav-text">适配器模式</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiao Qi</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




-->

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  



  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"tagMode":false});</script></body>
</html>
